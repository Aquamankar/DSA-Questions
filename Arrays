ğŸŒ¸ Day 1: Arrays â€“ Traversals, Basics

1.2 Zero Matrix problem

    public static void main(String[] args) {
        int [][] arr = {
            {0, 2, 3},
            {4, 5, 6},
            {7, 8, 0}
        };

        int m = arr.length;
        int n = arr[0].length;

        boolean[] zeroRows = new boolean[m];
        boolean[] zeroCols = new boolean[n];

        // Step 1: Find all rows and columns that have a 0
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (arr[i][j] == 0) {
                    zeroRows[i] = true;
                    zeroCols[j] = true;
                }
            }
        }

        // Step 2: Zero out rows
        for (int i = 0; i < m; i++) {
            if (zeroRows[i]) {
                for (int j = 0; j < n; j++) {
                    arr[i][j] = 0;
                }
            }
        }

        // Step 3: Zero out columns
        for (int j = 0; j < n; j++) {
            if (zeroCols[j]) {
                for (int i = 0; i < m; i++) {
                    arr[i][j] = 0;
                }
            }
        }

        // Print the modified matrix
        for (int[] row : arr) {
            for (int val : row) {
                System.out.print(val + " ");
            }
            System.out.println();
        }
    }



1.1 Subarray with most distinct elements:

import java.util.*;

public class Main {
    public static void main(String[] args) {
        int[] arr = {5, 1, 3, 5, 2, 3, 4, 1}; // Sample input
        findSubarrayWithMostDistinctElements(arr);
    }

    public static void findSubarrayWithMostDistinctElements(int[] arr) {
        int n = arr.length;
        Map<Integer, Integer> map = new HashMap<>(); // element -> frequency
        int left = 0, right = 0;
        int maxLen = 0, start = 0, end = 0;

        while (right < n) {
            // Add current element to the map
            map.put(arr[right], map.getOrDefault(arr[right], 0) + 1);

            // Shrink the window if duplicates present
            while (map.get(arr[right]) > 1) {
                map.put(arr[left], map.get(arr[left]) - 1);
                if (map.get(arr[left]) == 0) {
                    map.remove(arr[left]);
                }
                left++;
            }

            // Update max if current window has more distinct elements
            if (map.size() > maxLen) {
                maxLen = map.size();
                start = left;
                end = right;
            }

            right++;
        }

        System.out.println("Subarray with most distinct elements:");
        for (int i = start; i <= end; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println("\nNumber of distinct elements: " + maxLen);
    }
}
+---------------------_---------_------------------_----_-_--------

1.Find the maximum element in an array.


import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        System.out.println("Try programiz.pro");
        
        int[] arr = {1, 2, 4, 5, 6};
        
        // Find max in array using streams
        int ans = Arrays.stream(arr)
                        .max()
                        .orElse(0); // returns 0 if array is empty

        System.out.println("Maximum element is: " + ans);
    }
}


-----------------------------------------------------------------------------------------------------------


2.Find the minimum element in an array.


3.Calculate the sum and average of all elements.


4.Reverse the array (print or store in reverse).


5.Check if the array is sorted (in ascending order).


6.Find the second largest element.



import java.util.*;
class Main {
    public static void main(String[] args) {
        System.out.println("Try programiz.pro");
        // .Find the second largest element.
        int [] a1={1,4,2,5,3,56,77,8};
        int n=2;
        int ans=Arrays.stream(a1)
        .boxed()
        .sorted()
        .skip(a1.length - n)
        .findFirst()
        .get();
        
        
        
        int reverseAns=Arrays.stream(a1).
        boxed()
        .sorted(Comparator.reverseOrder())
        .skip(n-1).
        findFirst()
        .get();
        
        System.out.println("Try programiz.pro " + ans);
        System.out.println("Try programiz.pro " + reverseAns);
        

    }
}
-----------------------------------------------------------------------------------------------


7.Copy elements of one array into another.

import java.util.Arrays;

class Main {
    public static void main(String[] args) {
        int[] original = {1, 2, 3, 4, 5};

        // Method 1: System.arraycopy
        int[] copy1 = new int[original.length];
        System.arraycopy(original, 0, copy1, 0, original.length);

        // Method 2: Arrays.copyOf
        int[] copy2 = Arrays.copyOf(original, original.length);

        // Method 3: clone
        int[] copy3 = original.clone();

        // Method 4: Loop
        int[] copy4 = new int[original.length];
        for (int i = 0; i < original.length; i++) {
            copy4[i] = original[i];
        }

        // Method 5: Streams
        int[] copy5 = Arrays.stream(original).toArray();

        System.out.println("Original: " + Arrays.toString(original));
        System.out.println("Copy using System.arraycopy: " + Arrays.toString(copy1));
        System.out.println("Copy using Arrays.copyOf: " + Arrays.toString(copy2));
        System.out.println("Copy using clone: " + Arrays.toString(copy3));
        System.out.println("Copy using loop: " + Arrays.toString(copy4));
        System.out.println("Copy using Streams: " + Arrays.toString(copy5));
    }
}


-------------------------------------------------------------


8.Count the number of even and odd elements in an array.


9.Find the frequency of each element in an array.

---------------------------new--------------------------------------------------------------------------------
10.Subarrays with K Different Integers

exactlyK(k) = atMost(k) â€“ atMost(k-1)


import java.util.*;

class Main {
    public static void main(String[] args) {
        int[] nums = {1, 2, 1, 2, 3};
        int k = 2;

        int ans = subarraysWithKDistinct(nums, k);
        System.out.println("Subarrays with exactly " + k + " distinct = " + ans);
    }

    public static int subarraysWithKDistinct(int[] nums, int k) {
        return atMost(nums, k) - atMost(nums, k - 1);
    }

    private static int atMost(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        int l = 0, ans = 0;

        for (int r = 0; r < nums.length; r++) {
            map.put(nums[r], map.getOrDefault(nums[r], 0) + 1);

            while (map.size() > k) {
                map.put(nums[l], map.get(nums[l]) - 1);
                if (map.get(nums[l]) == 0) {
                    map.remove(nums[l]);
                }
                l++;
            }

            ans += r - l + 1; // all subarrays ending at r
        }

        return ans;
    }
}
=======================================================================
Count new subarrays ending at r
ans += r - l + 1;


ğŸ‘‰ Why (r - l + 1)?
Because:

Current valid window is [l â€¦ r].

Any subarray ending at r and starting anywhere between l and r is valid.

That means there are exactly:

[l â€¦ r], [l+1 â€¦ r], [l+2 â€¦ r], â€¦ [r â€¦ r]

========================================================================



atMost(k) = number of subarrays with at most k distinct integers.

atMost(k-1) = number of subarrays with at most (k-1) distinct integers.

Subtracting gives exactly k distinct.

ğŸ”¹ How atMost(nums, k) works (sliding window idea)

We keep a window [l â€¦ r] (left to right pointer).
At each step, we expand r (right pointer), and shrink l (left pointer) if we have more than k distinct numbers.




----------------------------------------------------------------------------------------------------------------

Q12   find the peak elemnt ----->


// Online Java Compiler
// Use this editor to write, compile and run your Java code online

class Main {
    public static void main(String[] args) {
        System.out.println("Try programiz.pro");
        
        int [] arr= {1,2,3,4,5,78,3,5,23,1,78,90};
        
        //find peek elements
        int low=0; int high=arr.length-1;
        
        while(low <= high){
            
            int mid =low +(high-low)/2;
            
            if((mid==0 || arr[mid] > arr[mid-1]) && (mid==arr.length-1 || arr [mid] >= arr[mid +1])){
                 System.out.println("Peak element: " + arr[mid]);
                return;  // Peak found, exit
            }
            
            if(mid < arr.length-1  && arr[mid ]< arr[mid+1]){
                low=mid+1;
            }else{
                high=mid-1;
            }
        }
        
        
    }
}


Find the largest and smallest element in a single traversal.


ğŸŒ¸ Day 2: Arrays â€“ Sorting, Searching

1.Sort the array using Bubble Sort.


2.Sort the array using Selection Sort.



class Main {
    public static void main(String[] args) {
        System.out.println("Try programiz.pro");
        //selection sort
        int [] arr={2,1,5,7,3,2,6};
        
        for(int i=0;i<arr.length;i++){
           
          
          int min=i;
            for(int j=i+1;j<arr.length;j++){
                if(arr[j] < arr[min]){
                    min=j;
                }
            }
            
            //swap with i to min
            
            int temp=arr[i];
            arr[i]=arr[min];
            arr[min]=temp;
            
        }
          for (int num : arr) {
            System.out.print(num + " ");
        }
        
    }
}



---------------------------------------------------------------------------------------------------


3.Sort the array using Insertion Sort.

public static void main(String[] args) {
        System.out.println("Try programiz.pro");
        //insertion sort
        int [] arr={2,1,5,7,3,2,6};
        
        for(int i=1;i<arr.length;i++){
            //arr[j ] sorted
            int j=i-1;
            int key=arr[i];
            while(j >=0 && arr[j] > key){
                arr[j+1]=arr[j];
                j--;
            }
            
            // insert the key at the right position
            arr[j + 1] = key;
            
        }
          for (int num : arr) {
            System.out.print(num + " ");
        }
        
    }
}
----------------------------------------------------------------------------------------------------------------------


4.Implement Binary Search (array must be sorted first).


5.Implement Linear Search (no need for sorted array).


6.Find the first occurrence of an element.


7.Find the last occurrence of an element.


8.Count the number of occurrences of an element.


9.Check if two arrays are equal (after sorting).


10.Merge two sorted arrays into a single sorted array.


----------------------------------------------------------------------------------------------------------------------------------------------------------

11.Merge overlapping intervals.

import java.util.*;

class Main {
    public static void main(String[] args) {
        int [][] intervals = {{1,2},{2,5},{3,7},{4,8}};
        
        // Step 1: sort intervals by start time
        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
        
        List<int[]> res = new ArrayList<>();
        
        int[] curr = intervals[0];
        
        for(int[] inter : intervals){
            if(inter[0] <= curr[1]) {
                // Overlap â†’ merge
                curr[1] = Math.max(curr[1], inter[1]);
            } else {
                // No overlap â†’ push current and reset
                res.add(curr);
                curr = inter;
            }
        }
        
        // Add last interval
        res.add(curr);
        
        // Print result
        for(int[] r : res){
            System.out.println(Arrays.toString(r));
        }
    }
}
-------------------------------------------------------------------------------------------------------------------------------

ğŸŒ¸ Day 3: Arrays â€“ Kadaneâ€™s Algorithm, Prefix Sum

1.Find the maximum subarray sum using Kadaneâ€™s Algorithm.

int max = arr[0], curr = arr[0];
for (int i = 1; i < arr.length; i++) {
    curr = Math.max(arr[i], curr + arr[i]);
    max = Math.max(max, curr);
}


2.Find the maximum sum subarray of size k.

int sum = 0, max = 0;for (int i = 0; i < k; i++)
 sum += arr[i];
max = sum;
for (int i = k; i < arr.length; i++) {
    sum += arr[i] - arr[i - k];
    max = Math.max(max, sum);
}


3.Find the prefix sum array for a given array.

public static int[] prefixSum(int[] arr) {
    int[] prefix = new int[arr.length];
    prefix[0] = arr[0];
    for (int i = 1; i < arr.length; i++) {
        prefix[i] = prefix[i - 1] + arr[i];
    }
    return prefix;
}
--------------------------------------------------------------------------

4.Given a prefix sum array, find the sum of elements between two given indices.

public static int rangeSum(int[] prefix, int i, int j) {
    if (i == 0) return prefix[j];
    return prefix[j] - prefix[i - 1];
}
-------------------------------------------------------------------------------
5.Find the equilibrium index (index where sum of left = sum of right).

public static int equilibriumIndex(int[] arr) {
    int totalSum = Arrays.stream(arr).sum();
    int leftSum = 0;

    for (int i = 0; i < arr.length; i++) {
        totalSum -= arr[i]; // Now totalSum is rightSum
        if (leftSum == totalSum) return i;
        leftSum += arr[i];
    }
    return -1;
}
--_-------------------------------------------------------------------------------------

6.Find the number of subarrays with a given sum (using prefix sums).


public static int subarraySum(int[] nums, int k) {
    Map<Integer, Integer> map = new HashMap<>();
    map.put(0, 1);
    int count = 0, sum = 0;

    for (int num : nums) {
        sum += num;
        if (map.containsKey(sum - k)) {
            count += map.get(sum - k);
        }
        map.put(sum, map.getOrDefault(sum, 0) + 1);
    }

    return count;
}
------------------------------------------------------------------------------------------------------------------
6.1 variation  finding the number of subarrays with sum equal to k with indexes

import java.util.*;

class Main {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, -2, 4, -4, 1, 5};
        int k = 4;

        // To store result as list of [startIndex, endIndex]
        List<int[]> result = new ArrayList<>();

        // prefixSum to index list map
        Map<Integer, List<Integer>> map = new HashMap<>();
        map.put(0, new ArrayList<>(Arrays.asList(-1)));  // handle subarray from start

        int sum = 0;

        for (int i = 0; i < arr.length; i++) {
            sum += arr[i];

            // Check if (sum - k) is already in map
            int rem = sum - k;
            if (map.containsKey(rem)) {
                for (int startIdx : map.get(rem)) {
                    result.add(new int[]{startIdx + 1, i}); // [start, end] of subarray
                }
            }

            // Add current sum to map
            map.putIfAbsent(sum, new ArrayList<>());
            map.get(sum).add(i);
        }

        System.out.println("Subarrays with sum = " + k + ":");
        for (int[] indices : result) {
            System.out.println("Start: " + indices[0] + ", End: " + indices[1]);
        }
        System.out.println("Total count: " + result.size());
    }
}
###############################################################

ğŸ§  Prefix Sum Concept Refresher:
sum is the prefix sum up to index i, i.e., arr[0] + arr[1] + ... + arr[i].

If thereâ€™s a previous prefix sum startSum such that:

ğ‘ ğ‘¢ğ‘šâˆ’ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ‘†ğ‘¢ğ‘š=ğ‘˜

sumâˆ’startSum=k
Then the subarray from startIdx + 1 to i has sum k.

####################################################################
 Why startIdx + 1?
Letâ€™s say we had a prefix sum of startSum at index startIdx.

And now, we are at index i with current prefix sum sum.

The subarray from index startIdx + 1 to i is the one where:

arr[startIdx+1]+arr[startIdx+2]+...+arr[i]=sumâˆ’startSum=k

arr[startIdx+1]+arr[startIdx+2]+...+arr[i]=sumâˆ’startSum=k
So we do:

java
Copy
Edit
result.add(new int[]{startIdx + 1, i});

-------------------------------_-----------------------------------------
7.Find the longest subarray with sum = 0 (important!).

public static int longestSubarrayWithZeroSum(int[] arr) {
    Map<Integer, Integer> map = new HashMap<>();
    int maxLen = 0, sum = 0;

    for (int i = 0; i < arr.length; i++) {
        sum += arr[i];

        if (sum == 0) maxLen = i + 1;
        else if (map.containsKey(sum)) {
            maxLen = Math.max(maxLen, i - map.get(sum));
        } else {
            map.put(sum, i);
        }
    }

    return maxLen;
}
--------------------------_-----------------------_------------------------------

8.Subarray sum divisible by k.

import java.util.*;

public class SubarraySumDivByK {
    public int subarraysDivByK(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, 1); // base case: subarray starts from index 0

        int sum = 0, count = 0;

        for (int num : nums) {
            sum += num;
            int mod = ((sum % k) + k) % k; // handle negative mods

            count += map.getOrDefault(mod, 0);
            map.put(mod, map.getOrDefault(mod, 0) + 1);
        }

        return count;
    }
}
#####â‚¹â‚¹â‚¹â‚¹â‚¹â‚¹################
So why store mod in map?
Because:

If two prefix sums give the same remainder when divided by k, the subarray between them has a sum divisible by k.

So:

We don't care about actual prefix sums or array values.

We care about how many times a certain remainder has appeared before.
#â‚¹â‚¹â‚¹â‚¹â‚¹â‚¹â‚¹â‚¹â‚¹â‚¹â‚¹â‚¹â‚¹â‚¹â‚¹#######â‚¹###â‚¹â‚¹â‚¹â‚¹â‚¹â‚¹â‚¹â‚¹â‚¹â‚¹######

You have prefix sums prefixSum[j] and prefixSum[i].

Then the sum of the subarray from i+1 to j is:
prefixSum[j] - prefixSum[i].

We want:
(prefixSum[j] - prefixSum[i]) % k == 0

â¡ï¸ This means:
prefixSum[j] % k == prefixSum[i] % k

--------------------------------------------------------------------------------

9.Minimum length subarray with sum â‰¥ given value.


10.Maximum length subarray with equal number of 0s and 1s (in a binary array).



11.Roated metrix at 90 degree

// Online Java Compiler
// Use this editor to write, compile and run your Java code online

class Main {
    public static void main(String[] args) {
        System.out.println("Try programiz.pro");
        
        int [][] arr={{1,2,3},{4,5,6},{6,7,8}};
        
        for(int i=0;i<arr.length;i++){
            for(int j=0;j<arr[i].length;j++){
              System.out.print(arr[i][j] +" ");
            }
             System.out.println();
        }
        
            System.out.println();
        //rotated 90 
        for(int i=0;i<arr.length;i++){
            for(int j=i;j<arr.length;j++){
                
                int  temp= arr[i][j];
                arr[i][j]=arr[j][i];
                arr[j][i]=temp;
            }
        }
        
             for(int i=0;i<arr.length;i++){
            for(int j=0;j<arr[i].length;j++){
              System.out.print(arr[i][j] +" ");
            }
             System.out.println();
        }
        
        
        
        // reverse each row
        
        for(int i=0;i<arr.length;i++){
            
            int left=0; int right=arr[i].length-1;
            
            while(left<right){
                
                int temp =arr[i][left];
                arr[i][left]=arr[i][right];
                arr[i][right]=temp;
                
                left++;
                right--;
            }
        }
             System.out.println();
        
           for(int i=0;i<arr.length;i++){
            for(int j=0;j<arr[i].length;j++){
              System.out.print(arr[i][j] +" ");
            }
             System.out.println();
        }
        
    }
}

What is XOR?
XOR (^) is a bitwise operation:


0 ^ 0 = 0  
1 ^ 0 = 1  
0 ^ 1 = 1  
1 ^ 1 = 0

Properties:

a ^ a = 0

a ^ 0 = a

XOR is commutative and associative



XOR Swap Logic

We know XOR properties:

a ^ a = 0

a ^ 0 = a

XOR is commutative & associative

So, to swap two numbers a and b without a temp variable:

a = a ^ b;
b = a ^ b; // (a ^ b) ^ b = a
a = a ^ b; // (a ^ b) ^ a = b


Now a and b are swapped.

ðŸ”¹ Basic XOR Swap Example
public class XorSwap {
    public static void main(String[] args) {
        int a = 5, b = 9;

        System.out.println("Before swap: a=" + a + ", b=" + b);

        a = a ^ b;
        b = a ^ b;
        a = a ^ b;

        System.out.println("After swap: a=" + a + ", b=" + b);
    }
}


ðŸ‘‰ Output:

Before swap: a=5, b=9
After swap: a=9, b=5

ðŸ”¹ XOR Swap Questions (Interview Style)

Swap two numbers without using third variable

Use XOR logic instead of temp.

Reverse a string using XOR swap

char[] arr = "akanksha".toCharArray();
int i = 0, j = arr.length - 1;
while (i < j) {
    arr[i] ^= arr[j];
    arr[j] ^= arr[i];
    arr[i] ^= arr[j];
    i++; j--;
}
System.out.println(new String(arr)); // output: "ahsknaka"


Swap even and odd indexed elements in an array

int[] arr = {1,2,3,4,5,6};
for (int i = 0; i < arr.length-1; i+=2) {
    arr[i] ^= arr[i+1];
    arr[i+1] ^= arr[i];
    arr[i] ^= arr[i+1];
}
// Result: {2,1,4,3,6,5}


Swap two numbers in an array given their indices

int[] arr = {10, 20, 30, 40};
int i = 1, j = 3;
arr[i] ^= arr[j];
arr[j] ^= arr[i];
arr[i] ^= arr[j];
// Result: {10,40,30,20}


Swap diagonal elements of a matrix
(XOR works to swap matrix[i][i] and matrix[i][n-1-i]).

âš ï¸ Important Note:

If i == j (same index), XOR swap makes it 0.

So always check if (i != j) before swapping in array/string.

ðŸ‘‰ Do you want me to create a list of XOR-only problems (like swapping, missing number, single number detection, etc.), or just stick with swapping variations?

---------------------------++++++++--------_---------------_--------------------------------------------------------------------------------_----_---_--------__---
1. Find the single non-repeating element





2.Find the two non-repeating elements




âš¡ Variations commonly asked in interviews:

Every element appears thrice except one â†’ use bitwise count method.

Two elements appear once, others appear twice â†’ use XOR + partitioning trick.

Element appears k times except one â†’ use modulo arithmetic on bit counts.

-------------------------------------------------------------------------------------------------------------------------------------
3.Check if subarray with XOR = K exists
import java.util.HashMap;
import java.util.Map;

class Main {
    public static void main(String[] args) {
        int[] arr = {1, 2, 4, 3, 2, 6};
        int k = 4;
        int count = 0;

        Map<Integer, Integer> freq = new HashMap<>();

        for (int num : arr) {
            // XOR property: if a ^ b = k, then b = a ^ k
            int complement = num ^ k;

            // Check how many times complement has appeared so far
            count += freq.getOrDefault(complement, 0);

            // Store current number in the map
            freq.put(num, freq.getOrDefault(num, 0) + 1);
        }

        System.out.println("Optimized count of pairs with XOR = " + k + " is: " + count);
    }
}

Letâ€™s define:

prefixXor[i] = XOR of arr[0..i]

For subarray (l..r), XOR is:

arr[l] ^ arr[l+1] ^ ... ^ arr[r] = prefixXor[r] ^ prefixXor[l-1]


So, we need:

prefixXor[r] ^ prefixXor[l-1] = K






-------------------------------------------------------------------------------------------------------------------------------------------



4. XOR of all subarrays

Return XOR of all elements in all subarrays



-----------------------------------------------------------------------------------

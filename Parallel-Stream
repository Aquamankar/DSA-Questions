A parallel stream in Java is just like a normal stream, 
but operations are split into multiple threads (internally using ForkJoinPool) for faster processing on large data.

Example 1: Sum of numbers (normal vs parallel)
import java.util.*;
import java.util.stream.*;

class Main {
    public static void main(String[] args) {
        List<Integer> numbers = IntStream.rangeClosed(1, 10).boxed().toList();

        // Normal Stream
        int sum1 = numbers.stream()
                          .reduce(0, Integer::sum);

        // Parallel Stream
        int sum2 = numbers.parallelStream()
                          .reduce(0, Integer::sum);

        System.out.println("Normal Stream Sum: " + sum1);
        System.out.println("Parallel Stream Sum: " + sum2);
    }
}


Output:

Normal Stream Sum: 55
Parallel Stream Sum: 55

Example 2: Printing elements (to see thread usage)
import java.util.*;
import java.util.stream.*;

class Main {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David", "Eve");

        // Parallel Stream (notice thread names)
        names.parallelStream()
             .forEach(name -> {
                 System.out.println(name + " - " + Thread.currentThread().getName());
             });
    }
}


Sample output (thread names may differ):

Charlie - ForkJoinPool.commonPool-worker-1
Alice - main
Eve - ForkJoinPool.commonPool-worker-3
David - ForkJoinPool.commonPool-worker-2
Bob - ForkJoinPool.commonPool-worker-4


ðŸ‘‰ Key points for interview/simple questions:

stream() â†’ sequential (single thread).

parallelStream() â†’ parallel (multiple threads).

Parallel streams are good for CPU-heavy, independent tasks.

Not good for small collections or shared mutable state (can cause overhead or race conditions).

Do you want me to also give you a tricky interview-style question on parallel streams (like order of output, performance difference, or when not to use it)?

Is this conversation helpful so far?

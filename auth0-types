Why TokenRelay fails in your current flow (short)

TokenRelay in Spring Cloud Gateway relays tokens that the gateway itself obtained and stores in its OAuth2AuthorizedClient (session/reactive context) during an OAuth2 login flow handled by the gateway.
If Auth-service performs the entire login and returns a token to the frontend, the gateway has no session-owned token to relay → TokenRelay can’t forward anything → requests routed via gateway arrive downstream without Authorization header → 401.

Three correct solutions (ranked by recommendedness + when to use)
Option A — Recommended: keep Auth-service as client, gateway as resource server; frontend sends the Authorization header (Bearer) to gateway

When to use: frontend (SPA/mobile/Postman) gets tokens from Auth-service/Auth0 and sends them with each request.

Why this is best:

Simple, standard OAuth2/JWT flow.

Gateway validates tokens locally and forwards them unchanged to microservices.

No special cross-service token passing needed.

What to do:

Auth-service performs login, returns JWT to the frontend (JSON response or cookie).

Frontend stores token and attaches:

Authorization: Bearer <token>


to calls to http://localhost:8080/....

Gateway configured as resource server (validates the JWT) and forwards header.

Downstream services validate JWT again.

Gateway application.yml (essential):

spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: https://dev-k8ekd2g84pjorj8r.us.auth0.com/


Gateway SecurityConfig (WebFlux):

// same as we discussed — oauth2ResourceServer(jwt -> jwt.jwtAuthenticationConverter(...))


No TokenRelay required. This is the cleanest and easiest to maintain.

Option B — Keep Auth-service issuing token and set it as an HttpOnly cookie, then let the Gateway convert cookie → Authorization header automatically (so the gateway can forward the token)

When to use: you want server-side login flow (Auth-service issues token and redirects user) and the frontend should not hold the raw token (cookie-based usage). This preserves a server-controlled login but still enables gateway routing.

How it works:

Auth-service logs user in with Auth0, receives access token.

Auth-service sets an HttpOnly cookie containing the access token (or short-lived session token referencing the real token) and redirects user to app URL (gateway).

Gateway has a GlobalFilter that reads that cookie and adds an Authorization: Bearer <token> header before routing to downstream services.

Downstream services validate the token as usual.

Security notes:

Use HttpOnly, Secure, SameSite=Strict/Lax for the cookie.

Beware CSRF when using cookies for auth — use CSRF protection or set cookie SameSite for APIs or use double-submit token pattern.

Refresh token handling: better to keep refresh tokens in Auth-service (server side) and return new access tokens to the gateway when needed.

Auth-service: set cookie & redirect (example):

// after exchanging code for token in Auth-service
String accessToken = authorizedClient.getAccessToken().getTokenValue();

ResponseCookie cookie = ResponseCookie.from("ACCESS_TOKEN", accessToken)
    .httpOnly(true)
    .secure(true)              // true in prod (HTTPS)
    .path("/")
    .sameSite("Lax")
    .maxAge(3600)              // match token lifetime
    .build();

return ResponseEntity.status(HttpStatus.FOUND)
    .header(HttpHeaders.SET_COOKIE, cookie.toString())
    .header(HttpHeaders.LOCATION, "https://your-frontend-or-gateway-url/")
    .build();


Gateway: GlobalFilter to transform cookie → Authorization header

import org.springframework.core.Ordered;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import reactor.core.publisher.Mono;

@Component
public class CookieToAuthHeaderFilter implements GlobalFilter, Ordered {

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String token = null;
        if (exchange.getRequest().getCookies().containsKey("ACCESS_TOKEN")) {
            token = exchange.getRequest().getCookies().getFirst("ACCESS_TOKEN").getValue();
        }
        if (token != null && !token.isEmpty()) {
            ServerHttpRequest mutated = exchange.getRequest().mutate()
                    .header("Authorization", "Bearer " + token)
                    .build();
            return chain.filter(exchange.mutate().request(mutated).build());
        }
        return chain.filter(exchange);
    }

    @Override
    public int getOrder() {
        return -100; // early in the chain so security sees the header
    }
}


This lets the gateway see the token as an Authorization header and validate/forward it. It effectively simulates the frontend sending the header while keeping the token in an HttpOnly cookie.

Option C — Move login to the Gateway (so TokenRelay actually works)

When to use: you want the gateway to manage user authentication (redirect to Auth0, hold OAuth2AuthorizedClient in its session), and gateway is the one making downstream calls on behalf of the user.

How it works:

Gateway performs OAuth2 login and stores the tokens in ReactiveOAuth2AuthorizedClientService.

TokenRelay will read the gateway's stored token and forward it downstream.

Why this is more complex / less flexible:

The gateway must handle user login flows and session state.

Works well for web apps where gateway is an app façade (browser flows), but not ideal if you have SPAs or mobile apps that expect tokens directly.

If you pick this approach, you must:

Configure the gateway as OAuth2 client and keep TokenRelay filter in routes.

Ensure user sessions are sticky or shared (if you have multiple gateway instances).

Practical recommendation for your case

You said: “auth-service generate-token but does not send to apigatway — explain and resolve”.

Best quick fixes (pick one):

If you control the frontend: do Option A. Let the frontend attach Authorization header to calls to the gateway. Easiest and interoperable with Postman, mobile apps, etc.

If you want server-side login where the gateway receives tokens from auth-service automatically: do Option B (Auth-service sets HttpOnly cookie -> Gateway cookie→header filter). This preserves server-side token handling and keeps tokens out of JS.

If you want gateway to fully own login & token storage: Option C (move login into gateway and use TokenRelay). Use only if you want gateway to run the OAuth2 login flow itself.

Things you must handle whichever option you choose

Token refresh: if access tokens expire, plan how refresh tokens are used (prefer server-side refresh via Auth-service, or silent refresh in frontend).

Token storage: avoid storing tokens in localStorage if XSS is a concern; prefer HttpOnly cookies if you can handle CSRF.

Audience/scopes: ensure aud in token matches the resource-server configuration (issuer-uri and audience if you enforce it).

Role claims mapping: keep your JwtAuthenticationConverter consistent across gateway and microservices (you already extract roles from https://dailycodebuffer.com/roles — keep that logic shared or duplicated consistently).

Example: Quick end-to-end using Option B (cookie method)

Auth-service: after successful exchange -> set ACCESS_TOKEN cookie and redirect user to https://gateway/.

Gateway: GlobalFilter CookieToAuthHeaderFilter (above) adds header Authorization: Bearer <token> before security filter runs.

Gateway security: oauth2ResourceServer(jwt -> ...) validates token and forwards to property-service.

Property-service: validates token, extracts roles and applies @PreAuthorize.

If you want I can:

Provide a complete minimal example project structure for Option B (Auth-service set-cookie; gateway filter + security config; property-service security config).

Or show a curl / Postman test flow for Option A (frontend attaches header).

Or show how to handle refresh tokens securely with option B.

Which one do you want coded out right now — A (frontend header), B (cookie+filter), or C (gateway login + TokenRelay)?

Iâ€™ll list each pattern â give 5â€“10 handpicked problems under it.
This will serve as a pattern â†’ practice set roadmap for you.

ğŸ“˜ Pattern-Wise DSA Practice Questions

----------------------------------------------------------------------------------------------------------------------------------------------
1ï¸âƒ£ Sliding Window Pattern

Used for substring/array problems where we check contiguous ranges.

Problems:

Maximum Sum Subarray of Size K

Longest Substring Without Repeating Characters

Longest Substring with At Most K Distinct Characters

Minimum Window Substring

Find All Anagrams in a String

Permutation in String (Check if s2 contains permutation of s1)

Longest Repeating Character Replacement



=========================================================================================================
Subarrays with K Different Integers


2ï¸âƒ£ Idea

A very neat trick:

Number of subarrays with exactly K distinct integers =
number of subarrays with â‰¤ K distinct integers - number of subarrays with â‰¤ (K-1) distinct integers

Why?

â€œâ‰¤ Kâ€ counts all subarrays with 1,2,â€¦,K distinct numbers

Subtract â€œâ‰¤ K-1â€ to leave exactly K.

3ï¸âƒ£ Implementation â€” Sliding Window
import java.util.*;

class Main {
    public static void main(String[] args) {
        int[] nums = {1,2,1,2,3};
        int K = 2;

        int result = subarraysWithKDistinct(nums, K);
        System.out.println(result); // Output: 7
    }

    public static int subarraysWithKDistinct(int[] nums, int K) {
        return atMostK(nums, K) - atMostK(nums, K - 1);
    }

    public static int atMostK(int[] nums, int K) {
        Map<Integer, Integer> count = new HashMap<>();
        int left = 0, res = 0;

        for (int right = 0; right < nums.length; right++) {
            count.put(nums[right], count.getOrDefault(nums[right], 0) + 1);

            while (count.size() > K) {
                count.put(nums[left], count.get(nums[left]) - 1);
                if (count.get(nums[left]) == 0)
                    count.remove(nums[left]);
                left++;
            }

            res += right - left + 1; // all subarrays ending at 'right'
        }

        return res;
    }
}

4ï¸âƒ£ How it works

atMostK(nums, K) counts all subarrays with â‰¤ K distinct integers

atMostK(nums, K-1) counts all subarrays with â‰¤ K-1 distinct integers

Subtract â†’ exactly K distinct integer






======================================================================================================
Smallest Subarray with Sum â‰¥ K

How to Solve (Idea):

Use a sliding window:

Start with two pointers: l (left) and r (right) at start of array.

Expand r and add nums[r] to current sum.

If sum â‰¥ target â†’ try shrinking window from l to minimize length.

Keep track of the smallest length during this process.

Time complexity: O(n) because each element is visited at most twice (once by r, once by l).
---------------------------------------------------------------------------------------------------------------------------

for negative use deques


import java.util.*;

class Main {
    public static void main(String[] args) {
        int[] arr = {1, 3, 6, 9, -6, 1};
        int k = 10;

        int n = arr.length;
        long[] prefix = new long[n + 1];
        for (int i = 0; i < n; i++) {
            prefix[i + 1] = prefix[i] + arr[i];
        }

        Deque<Integer> dq = new ArrayDeque<>();
        int minLen = Integer.MAX_VALUE;

        for (int i = 0; i <= n; i++) {
            // while current prefix - smallest prefix >= k
            while (!dq.isEmpty() && prefix[i] - prefix[dq.peekFirst()] >= k) {
                minLen = Math.min(minLen, i - dq.pollFirst());
            }

            // maintain increasing prefix sums
            while (!dq.isEmpty() && prefix[i] <= prefix[dq.peekLast()]) {
                dq.pollLast();
            }

            dq.offerLast(i);
        }

        if (minLen == Integer.MAX_VALUE)
            System.out.println("No subarray found");
        else
            System.out.println("Smallest subarray length with sum â‰¥ " + k + " is: " + minLen);
    }
}
--------------------------------------------------------------



Iteration i=1 (prefix[1]=1)

prefix[1] â‰¥ prefix[0] + k? 1-0 â‰¥ 10? âŒ

Remove from back if prefix[i] â‰¤ prefix[dq.back]? 1 â‰¤ 0? âŒ

Add 1 at back â†’ dq = [0,1]

Iteration i=2 (prefix[2]=4)

Check front: prefix[2]-prefix[0]=4-0=4 < 10 â†’ âŒ

Check back: prefix[2] â‰¤ prefix[1]? 4 â‰¤ 1? âŒ

Add 2 at back â†’ dq = [0,1,2]

Iteration i=3 (prefix[3]=10)

Check front: prefix[3]-prefix[0]=10-0=10 âœ…

Found subarray length = 3-0=3 â†’ update minLen = 3

Remove front 0 â†’ dq=[1,2]

Check front again: prefix[3]-prefix[1]=10-1=9 < 10 âŒ

Remove from back if prefix[3] â‰¤ prefix[dq.back]? 10 â‰¤ 4 âŒ

Add 3 at back â†’ dq=[1,2,3]
-------------------------------------------------------------------------------------------------------------------------------
=====================================================

Max Consecutive Ones (with at most K flips)
==â‰ ========â‰ ==============({{{{{======â‰ =â‰ â‰ ===â‰ =======


âœ… Approach â€” Sliding Window

This is a classic sliding window problem.

ğŸ§  Logic:

Keep a window [left, right].

Count how many zeros are inside the window.

If zeros > K â†’ move left pointer until zeros â‰¤ K again.

Track the maximum window size.
,=======================================â‰ =====â‰ ========â‰ ==â‰ â‰ =â‰ â€²Â°Â°Â°Â°â€²Â°Â°Â°

2ï¸âƒ£ Two Pointers Pattern

Used for sorted arrays / linked lists problems.

Problems:

Two Sum (sorted array version)


======================================================================================
3Sum


import java.util.*;

public class Main {
    public static void main(String[] args) {
        int[] nums = {-1, 0, 1, 2, -1, -4};
        List<List<Integer>> result = threeSum(nums);
        System.out.println(result);
    }

    public static List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(nums); // Step 1: sort array
        int n = nums.length;

        for (int i = 0; i < n - 2; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue; // skip duplicates

            int left = i + 1;
            int right = n - 1;

            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];

                if (sum == 0) {
                    res.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    left++;
                    right--;

                    // skip duplicates
                    while (left < right && nums[left] == nums[left - 1]) left++;
                    while (left < right && nums[right] == nums[right + 1]) right--;

                } else if (sum < 0) {
                    left++;
                } else {
                    right--;
                }
            }
        }
        return res;
    }
}



=======================================================================================================
4Sum

import java.util.*;

public class FourSum {
    public static List<List<Integer>> fourSum(int[] nums, int target) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        int n = nums.length;

        for (int i = 0; i < n - 3; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            for (int j = i + 1; j < n - 2; j++) {
                if (j > i + 1 && nums[j] == nums[j - 1]) continue;
                int left = j + 1, right = n - 1;
                while (left < right) {
                    long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];
                    if (sum == target) {
                        res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));
                        left++;
                        right--;
                        while (left < right && nums[left] == nums[left - 1]) left++;
                        while (left < right && nums[right] == nums[right + 1]) right--;
                    } else if (sum < target) left++;
                    else right--;
                }
            }
        }
        return res;
    }
}
==================================================================================================Ã·Ã·Ã·Ã·Ã·Ã·Ã·Ã·Ã·Ã·=============
Container With Most Water


public class ContainerWithMostWater {

    public static int maxArea(int[] height) {
        int left = 0, right = height.length - 1;
        int max = 0;

        while (left < right) {
            int area = Math.min(height[left], height[right]) * (right - left);
            max = Math.max(max, area);

            // Move the pointer with smaller height
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }

        return max;
    }

    public static void main(String[] args) {
        int[] height = {1,8,6,2,5,4,8,3,7};
        int result = maxArea(height);
        System.out.println("Maximum area: " + result); // Output: 49
    }
}


**********************************************

ğŸŒŠ Problem Explanation (Simple)

You are given an array:

[1,8,6,2,5,4,8,3,7]


Each number is the height of a vertical line.

Your job is to pick two lines that can hold maximum water between them.

Water is stored as a rectangle between two lines.

ğŸ§  How do we calculate area (water)?

Formula:

Area = (shorter line) Ã— (distance between two lines)

Why shorter line?
Because water spills out from the shorter side.

Example:
If heights are 8 and 3 â†’
Water can go only up to 3 height.

So:

area = min(8, 3) * distance


Distance means:
rightIndex - leftIndex

ğŸ¯ Two Pointer Logic (SUPER IMPORTANT)

We start with:

left = first line
right = last line


Why?

Because this gives us the maximum width.

After calculating area, we have two heights:

Example:

height[left] = 1
height[right] = 7


The shorter one is 1.

â†’ Water can only go up to height 1
So if we move the taller line (7), it wonâ€™t help.

ğŸ’¡ Only moving the smaller height can give a better result.

That is the golden rule:

if leftHeight < rightHeight: left++
else: right--


========================================================================================

Trapping Rain Water (Two Pointer version)


class Main {
    public static void main(String[] args) {
        int[] arr = {2, 1, 5, 6, 7, 7};
        int water = 0, leftmax = 0, rightmax = 0;
        int l = 0, r = arr.length - 1;

        while (l < r) {
            if (arr[l] < arr[r]) {
                if (leftmax < arr[l]) {
                    leftmax = arr[l];
                } else {
                    water += leftmax - arr[l]; // âœ… correct difference
                }
                l++;
            } else {
                if (rightmax <= arr[r]) {
                    rightmax = arr[r];
                } else {
                    water += rightmax - arr[r]; // âœ… correct difference
                }
                r--;
            }
        }

        System.out.println("Total trapped water: " + water);
    }
}




=========================================={{{{{{{==========================================
Remove Duplicates from Sorted Array

Move Zeroes

Sort Colors (Dutch National Flag problem)

Minimum Difference Pair from Two Arrays

Intersection of Two Arrays

3ï¸âƒ£ Fast & Slow Pointers (Cycle Detection)

Used in linked lists / circular arrays.

Problems:

Linked List Cycle Detection

Find the Starting Node of Cycle in Linked List


==========================================================================================
Happy Number

import java.util.*;

class Main {
    public static void main(String[] args) {
        int n = 19; // try changing this number
        if (isHappy(n))
            System.out.println(n + " is a Happy Number ğŸ˜Š");
        else
            System.out.println(n + " is NOT a Happy Number ğŸ˜¢");
    }

    public static boolean isHappy(int n) {
        Set<Integer> seen = new HashSet<>();

        while (n != 1 && !seen.contains(n)) {
            seen.add(n);
            n = getSquareSum(n);
        }

        return n == 1;
    }

    private static int getSquareSum(int n) {
        int sum = 0;
        while (n > 0) {
            int digit = n % 10;
            sum += digit * digit;
            n /= 10;
        }
        return sum;
    }
}


=========================================================================================
Middle of Linked List

Palindrome Linked List (using reverse 2nd half)

Detect Cycle in Circular Array

Find Duplicate Number (Floydâ€™s cycle detection)

Intersection Node of Two Linked Lists

4ï¸âƒ£ Merge Intervals Pattern

Used when problems involve overlapping in

tervals.

Problems:
===================================================================================================================================
Merge Intervals

import java.util.*;

public class MergeIntervals {
    public static int[][] merge(int[][] intervals) {
        if (intervals.length <= 1) return intervals;

        Arrays.sort(intervals, (a, b) -> a[0] - b[0]); // sort by start
        List<int[]> result = new ArrayList<>();
        int[] current = intervals[0];

        for (int i = 1; i < intervals.length; i++) {
            if (intervals[i][0] <= current[1]) { // overlap
                current[1] = Math.max(current[1], intervals[i][1]);
            } else {
                result.add(current);
                current = intervals[i];
            }
        }
        result.add(current);

        return result.toArray(new int[result.size()][]);
    }

    public static void main(String[] args) {
        int[][] intervals = {{1,3},{2,6},{8,10},{15,18}};
        int[][] merged = merge(intervals);
        for (int[] interval : merged) System.out.println(Arrays.toString(interval));
    }
}

======================================================================================================


Insert Interval




import java.util.*;

public class InsertInterval {
    public static int[][] insert(int[][] intervals, int[] newInterval) {
        List<int[]> result = new ArrayList<>();
        int i = 0;

        // Add intervals before newInterval
        while (i < intervals.length && intervals[i][1] < newInterval[0]) {
            result.add(intervals[i++]);
        }

        // Merge overlapping intervals
        while (i < intervals.length && intervals[i][0] <= newInterval[1]) {
            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);
            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);
            i++;
        }
        result.add(newInterval);

        // Add remaining intervals
        while (i < intervals.length) result.add(intervals[i++]);

        return result.toArray(new int[result.size()][]);
    }

    public static void main(String[] args) {
        int[][] intervals = {{1,3},{6,9}};
        int[] newInterval = {2,5};
        int[][] merged = insert(intervals, newInterval);
        for (int[] interval : merged) System.out.println(Arrays.toString(interval));
    }
}
=====================================================================================================

Interval List Intersections

import java.util.*;

public class IntervalListIntersections {
    public static void main(String[] args) {
        int[][] A = {{0,2},{5,10},{13,23},{24,25}};
        int[][] B = {{1,5},{8,12},{15,24},{25,26}};
        
        int[][] result = intervalIntersection(A, B);
        
        for (int[] interval : result) {
            System.out.println(Arrays.toString(interval));
        }
    }
    
    public static int[][] intervalIntersection(int[][] A, int[][] B) {
        List<int[]> result = new ArrayList<>();
        int i = 0, j = 0;
        
        while (i < A.length && j < B.length) {
            int start = Math.max(A[i][0], B[j][0]);
            int end = Math.min(A[i][1], B[j][1]);
            
            if (start <= end) {
                result.add(new int[]{start, end});
            }
            
            // Move the interval that ends first
            if (A[i][1] < B[j][1]) i++;
            else j++;
        }
        
        return result.toArray(new int[result.size()][]);
    }
}



============================================================================================================
Minimum Number of Meeting Rooms



import java.util.*;

public class MinimumMeetingRooms {
    public static void main(String[] args) {
        int[][] intervals = {{0,30},{5,10},{15,20}};
        System.out.println(minMeetingRooms(intervals));
    }
    
    public static int minMeetingRooms(int[][] intervals) {
        if (intervals.length == 0) return 0;
        
        int n = intervals.length;
        int[] start = new int[n];
        int[] end = new int[n];
        
        for (int i = 0; i < n; i++) {
            start[i] = intervals[i][0];
            end[i] = intervals[i][1];
        }
        
        Arrays.sort(start);
        Arrays.sort(end);
        
        int rooms = 0, endPtr = 0;
        
        for (int i = 0; i < n; i++) {
            if (start[i] < end[endPtr]) {
                rooms++; // need another room
            } else {
                endPtr++; // meeting ended
            }
        }
        
        return rooms;
    }
}


================================================================================================================

Employee Free Time

Non-overlapping Intervals

Task Scheduler (interval + heap hybrid)

5ï¸âƒ£ Cyclic Sort Pattern

Used for array problems with numbers in a range (1..n).

Problems:

Cyclic Sort (base)
==========================================================================================
Find Missing Number

ğŸŸ¢ 1ï¸âƒ£ Find the Missing Number

ğŸ‘‰ Numbers are from 0 to n (one number missing).

ğŸ”¹ Logic

Since range is 0..n, each number should be at index num.

One number is missing â†’ one index will not have the correct number.

ğŸ”¹ Code
public class MissingNumber {
    public static int findMissingNumber(int[] nums) {
        int i = 0;
        while (i < nums.length) {
            int correctIndex = nums[i];
            if (nums[i] < nums.length && nums[i] != nums[correctIndex]) {
                int temp = nums[i];
                nums[i] = nums[correctIndex];
                nums[correctIndex] = temp;
            } else {
                i++;
            }
        }

        for (i = 0; i < nums.length; i++) {
            if (nums[i] != i)
                return i;
        }
        return nums.length; // if all 0..n-1 are present
    }

    public static void main(String[] args) {
        int[] nums = {3, 0, 1};
        System.out.println(findMissingNumber(nums)); // Output: 2
    }
}


â±ï¸ Time: O(n)â€ƒğŸ’¾ Space: O(1)



================================================================================================
Find All Missing Numbers

ğŸŸ¢ 2ï¸âƒ£ Find All Missing Numbers

ğŸ‘‰ Numbers are from 1 to n but some are missing and some may repeat.

ğŸ”¹ Logic

After cyclic sorting:

Numbers that are not at their correct index are missing.
Missing number = index + 1

ğŸ”¹ Code
import java.util.*;

public class AllMissingNumbers {
    public static List<Integer> findDisappearedNumbers(int[] nums) {
        int i = 0;
        while (i < nums.length) {
            int correctIndex = nums[i] - 1;
            if (nums[i] != nums[correctIndex]) {
                int temp = nums[i];
                nums[i] = nums[correctIndex];
                nums[correctIndex] = temp;
            } else {
                i++;
            }
        }

        List<Integer> missing = new ArrayList<>();
        for (i = 0; i < nums.length; i++) {
            if (nums[i] != i + 1)
                missing.add(i + 1);
        }
        return missing;
    }

    public static void main(String[] args) {
        int[] nums = {4,3,2,7,8,2,3,1};
        System.out.println(findDisappearedNumbers(nums)); // Output: [5,6]
    }
}


â±ï¸ Time: O(n)â€ƒğŸ’¾ Space: O(1)


===================================================================================================

Find the Duplicate Number

public class FindDuplicate {
    public static int findDuplicate(int[] nums) {
        int i = 0;
        while (i < nums.length) {
            if (nums[i] != i + 1) {
                int correctIndex = nums[i] - 1;
                if (nums[i] == nums[correctIndex]) return nums[i];
                int temp = nums[i];
                nums[i] = nums[correctIndex];
                nums[correctIndex] = temp;
            } else {
                i++;
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        int[] nums = {3,1,3,4,2};
        System.out.println(findDuplicate(nums)); // Output: 3
    }
}


========================================================================================================

Find All Duplicates in an Array

ğŸŸ¢ 4ï¸âƒ£ Find All Duplicates in an Array

ğŸ‘‰ Multiple numbers appear twice.

ğŸ”¹ Logic

After sorting with cyclic sort:

If nums[i] != i + 1, then nums[i] is a duplicate.

ğŸ”¹ Code
import java.util.*;

public class AllDuplicates {
    public static List<Integer> findDuplicates(int[] nums) {
        int i = 0;
        while (i < nums.length) {
            int correctIndex = nums[i] - 1;
            if (nums[i] != nums[correctIndex]) {
                int temp = nums[i];
                nums[i] = nums[correctIndex];
                nums[correctIndex] = temp;
            } else {
                i++;
            }
        }

        List<Integer> duplicates = new ArrayList<>();
        for (i = 0; i < nums.length; i++) {
            if (nums[i] != i + 1)
                duplicates.add(nums[i]);
        }
        return duplicates;
    }

    public static void main(String[] args) {
        int[] nums = {4,3,2,7,8,2,3,1};
        System.out.println(findDuplicates(nums)); // Output: [2,3]
    }
}


===================================================================================================================

First Missing Positive


ğŸŸ¢ 5ï¸âƒ£ First Missing Positive

ğŸ‘‰ Find the smallest missing positive integer (can include negatives and zeros).

ğŸ”¹ Logic

Ignore negative and out-of-range numbers.

Place each positive number x at index x - 1.

The first index where nums[i] != i + 1 â†’ missing positive.

ğŸ”¹ Code
public class FirstMissingPositive {
    public static int firstMissingPositive(int[] nums) {
        int i = 0;
        while (i < nums.length) {
            int correctIndex = nums[i] - 1;
            if (nums[i] > 0 && nums[i] <= nums.length && nums[i] != nums[correctIndex]) {
                int temp = nums[i];
                nums[i] = nums[correctIndex];
                nums[correctIndex] = temp;
            } else {
                i++;
            }
        }

        for (i = 0; i < nums.length; i++) {
            if (nums[i] != i + 1)
                return i + 1;
        }
        return nums.length + 1;
    }

    public static void main(String[] args) {
        int[] nums = {3,4,-1,1};
        System.out.println(firstMissingPositive(nums)); // Output: 2
    }
}
==================================================================================================================
Set Mismatch




===================================================================================================================
6ï¸âƒ£ In-place Linked List Reversal

Used for reversing linked lists in parts.

Problems:

Reverse Linked List

Reverse Linked List II (between positions m and n)

Reverse Nodes in K-Group

Rotate Linked List

Reorder List

Swap Nodes in Pairs

7ï¸âƒ£ Tree BFS Pattern

Level-order traversal type.

Problems:

Binary Tree Level Order Traversal

Binary Tree Zigzag Level Order Traversal

Average of Levels in Binary Tree

Maximum Depth of Binary Tree (BFS)

Minimum Depth of Binary Tree

Binary Tree Right Side View

Cousins in Binary Tree

8ï¸âƒ£ DFS (Recursion/Stack)

Used for exploring trees/graphs recursively.

Problems:

Maximum Depth of Binary Tree (DFS)

Diameter of Binary Tree

Path Sum I / II

Symmetric Tree (DFS)

Subtree of Another Tree

Count Good Nodes in Binary Tree

Number of Islands (DFS version)

9ï¸âƒ£ Two Heaps Pattern

Used for median and scheduling problems.

Problems:

Find Median from Data Stream

Sliding Window Median

IPO (maximize capital with projects)

Find Right Interval

Meeting Rooms II (Heap version)

ğŸ”Ÿ Subsets Pattern

Used for generating combinations / permutations.

Problems:

Subsets (all subsets)

Subsets II (with duplicates)

Permutations

Permutations II (with duplicates)

Combination Sum

Combination Sum II

Palindrome Partitioning

Letter Combinations of a Phone Number

1ï¸âƒ£1ï¸âƒ£ Modified Binary Search

Used for rotated arrays, peaks, searching problems.

Problems:

Binary Search (base)

Search in Rotated Sorted Array

Find Minimum in Rotated Sorted Array

Find Peak Element

First and Last Position of Element in Sorted Array

Single Element in a Sorted Array

Median of Two Sorted Arrays

1ï¸âƒ£2ï¸âƒ£ Bitwise XOR Pattern

Used for finding missing / unique elements.

Problems:

Single Number (every element appears twice except one)

Single Number II (appears 3 times except one)

Missing Number

Two Single Numbers (find 2 unique numbers in array)

Find XOR of numbers in range

1ï¸âƒ£3ï¸âƒ£ Top K Elements (Heap)

Used with PriorityQueue.

Problems:

Kth Largest Element in Array

Top K Frequent Elements

Top K Frequent Words

K Closest Points to Origin

Connect Ropes to Minimize Cost

Reorganize String

Sort Characters by Frequency

1ï¸âƒ£4ï¸âƒ£ 0/1 Knapsack DP

Classic subset DP.

Problems:

0/1 Knapsack

Subset Sum Problem

Partition Equal Subset Sum

Target Sum

Coin Change

Minimum Number of Coins to Make Amount

Unbounded Knapsack

1ï¸âƒ£5ï¸âƒ£ Topological Sort (Graph Ordering)

Used in DAG problems.

Problems:

Course Schedule I

Course Schedule II

Alien Dictionary

Minimum Height Trees

Sequence Reconstruction

1ï¸âƒ£6ï¸âƒ£ Greedy Pattern

Used when locally optimal = globally optimal.

Problems:

Jump Game I

Jump Game II

Gas Station

Candy Distribution

Non-overlapping Intervals (greedy)

Minimum Number of Arrows to Burst Balloons

1ï¸âƒ£7ï¸âƒ£ Matrix Traversal Pattern

Used for grid/2D problems.

Problems:

Number of Islands

Word Search

Surrounded Regions

Rotting Oranges

Spiral Matrix

Flood Fill

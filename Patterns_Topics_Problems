I‚Äôll list each pattern ‚ûù give 5‚Äì10 handpicked problems under it.
This will serve as a pattern ‚Üí practice set roadmap for you.

üìò Pattern-Wise DSA Practice Questions

----------------------------------------------------------------------------------------------------------------------------------------------
1Ô∏è‚É£ Sliding Window Pattern

Used for substring/array problems where we check contiguous ranges.

Problems:

Maximum Sum Subarray of Size K

Longest Substring Without Repeating Characters

Longest Substring with At Most K Distinct Characters

Minimum Window Substring

---------------------------------
Find All Anagrams in a String
public static List<Integer> findAnagrams(String s, String p) {
    List<Integer> result = new ArrayList<>();
    Map<Character, Integer> map = new HashMap<>();
    for (char c : p.toCharArray())
        map.put(c, map.getOrDefault(c, 0) + 1);

    int left = 0, matched = 0;

    for (int right = 0; right < s.length(); right++) {
        char c = s.charAt(right);
        if (map.containsKey(c)) {
            map.put(c, map.get(c) - 1);
            if (map.get(c) == 0) matched++;
        }

        if (right >= p.length() - 1) {
            if (matched == map.size()) result.add(left);

            char leftChar = s.charAt(left);
            if (map.containsKey(leftChar)) {
                if (map.get(leftChar) == 0) matched--;
                map.put(leftChar, map.get(leftChar) + 1);
            }
            left++;
        }
    }
    return result;
}


----------------------------------------------------------------

Permutation in String (Check if s2 contains permutation of s1)


--------------------------------------------------------------------
Longest Repeating Character Replacement




public int characterReplacement(String s, int k) {
    Map<Character, Integer> map = new HashMap<>();

    int left = 0;
    int maxFreq = 0;
    int maxLen = 0;

    for (int right = 0; right < s.length(); right++) {
        char c = s.charAt(right);
        map.put(c, map.getOrDefault(c, 0) + 1);

        maxFreq = Math.max(maxFreq, map.get(c));

        while (right - left + 1 - maxFreq > k) {
            char leftChar = s.charAt(left);
            map.put(leftChar, map.get(leftChar) - 1);
            left++;
        }

        maxLen = Math.max(maxLen, right - left + 1);
    }
    return maxLen;
}


formula -> replacements needed = window size ‚àí frequency of most common character
replacements needed ‚â§ k
window is valid


=========================================================================================================
Subarrays with K Different Integers


2Ô∏è‚É£ Idea

A very neat trick:

Number of subarrays with exactly K distinct integers =
number of subarrays with ‚â§ K distinct integers - number of subarrays with ‚â§ (K-1) distinct integers

Why?

‚Äú‚â§ K‚Äù counts all subarrays with 1,2,‚Ä¶,K distinct numbers

Subtract ‚Äú‚â§ K-1‚Äù to leave exactly K.

3Ô∏è‚É£ Implementation ‚Äî Sliding Window
import java.util.*;

class Main {
    public static void main(String[] args) {
        int[] nums = {1,2,1,2,3};
        int K = 2;

        int result = subarraysWithKDistinct(nums, K);
        System.out.println(result); // Output: 7
    }

    public static int subarraysWithKDistinct(int[] nums, int K) {
        return atMostK(nums, K) - atMostK(nums, K - 1);
    }

    public static int atMostK(int[] nums, int K) {
        Map<Integer, Integer> count = new HashMap<>();
        int left = 0, res = 0;

        for (int right = 0; right < nums.length; right++) {
            count.put(nums[right], count.getOrDefault(nums[right], 0) + 1);

            while (count.size() > K) {
                count.put(nums[left], count.get(nums[left]) - 1);
                if (count.get(nums[left]) == 0)
                    count.remove(nums[left]);
                left++;
            }

            res += right - left + 1; // all subarrays ending at 'right'
        }

        return res;
    }
}

4Ô∏è‚É£ How it works

atMostK(nums, K) counts all subarrays with ‚â§ K distinct integers

atMostK(nums, K-1) counts all subarrays with ‚â§ K-1 distinct integers

Subtract ‚Üí exactly K distinct integer






======================================================================================================
Smallest Subarray with Sum ‚â• K

How to Solve (Idea):

Use a sliding window:

Start with two pointers: l (left) and r (right) at start of array.

Expand r and add nums[r] to current sum.

If sum ‚â• target ‚Üí try shrinking window from l to minimize length.

Keep track of the smallest length during this process.

Time complexity: O(n) because each element is visited at most twice (once by r, once by l).
---------------------------------------------------------------------------------------------------------------------------

for negative use deques


import java.util.*;

class Main {
    public static void main(String[] args) {
        int[] arr = {1, 3, 6, 9, -6, 1};
        int k = 10;

        int n = arr.length;
        long[] prefix = new long[n + 1];
        for (int i = 0; i < n; i++) {
            prefix[i + 1] = prefix[i] + arr[i];
        }

        Deque<Integer> dq = new ArrayDeque<>();
        int minLen = Integer.MAX_VALUE;

        for (int i = 0; i <= n; i++) {
            // while current prefix - smallest prefix >= k
            while (!dq.isEmpty() && prefix[i] - prefix[dq.peekFirst()] >= k) {
                minLen = Math.min(minLen, i - dq.pollFirst());
            }

            // maintain increasing prefix sums
            while (!dq.isEmpty() && prefix[i] <= prefix[dq.peekLast()]) {
                dq.pollLast();
            }

            dq.offerLast(i);
        }

        if (minLen == Integer.MAX_VALUE)
            System.out.println("No subarray found");
        else
            System.out.println("Smallest subarray length with sum ‚â• " + k + " is: " + minLen);
    }
}
--------------------------------------------------------------



Iteration i=1 (prefix[1]=1)

prefix[1] ‚â• prefix[0] + k? 1-0 ‚â• 10? ‚ùå

Remove from back if prefix[i] ‚â§ prefix[dq.back]? 1 ‚â§ 0? ‚ùå

Add 1 at back ‚Üí dq = [0,1]

Iteration i=2 (prefix[2]=4)

Check front: prefix[2]-prefix[0]=4-0=4 < 10 ‚Üí ‚ùå

Check back: prefix[2] ‚â§ prefix[1]? 4 ‚â§ 1? ‚ùå

Add 2 at back ‚Üí dq = [0,1,2]

Iteration i=3 (prefix[3]=10)

Check front: prefix[3]-prefix[0]=10-0=10 ‚úÖ

Found subarray length = 3-0=3 ‚Üí update minLen = 3

Remove front 0 ‚Üí dq=[1,2]

Check front again: prefix[3]-prefix[1]=10-1=9 < 10 ‚ùå

Remove from back if prefix[3] ‚â§ prefix[dq.back]? 10 ‚â§ 4 ‚ùå

Add 3 at back ‚Üí dq=[1,2,3]
-------------------------------------------------------------------------------------------------------------------------------
=====================================================

Max Consecutive Ones (with at most K flips)
==‚â†========‚â†==============({{{{{======‚â†=‚â†‚â†===‚â†=======


‚úÖ Approach ‚Äî Sliding Window

This is a classic sliding window problem.

üß† Logic:

Keep a window [left, right].

Count how many zeros are inside the window.

If zeros > K ‚Üí move left pointer until zeros ‚â§ K again.

Track the maximum window size.
,=======================================‚â†=====‚â†========‚â†==‚â†‚â†=‚â†‚Ä≤¬∞¬∞¬∞¬∞‚Ä≤¬∞¬∞¬∞

2Ô∏è‚É£ Two Pointers Pattern

Used for sorted arrays / linked lists problems.

Problems:

Two Sum (sorted array version)


class Solution {
    public int[] twoSum(int[] numbers, int target) {

        int left = 0, right = numbers.length - 1;

        while (left < right) {
            int sum = numbers[left] + numbers[right];

            if (sum == target) {
                return new int[]{left + 1, right + 1}; // 1-based index
            } else if (sum < target) {
                left++;
            } else {
                right--;
            }
        }
        return new int[]{-1, -1}; // safety fallback
    }
}


======================================================================================
3Sum


import java.util.*;

public class Main {
    public static void main(String[] args) {
        int[] nums = {-1, 0, 1, 2, -1, -4};
        List<List<Integer>> result = threeSum(nums);
        System.out.println(result);
    }

    public static List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(nums); // Step 1: sort array
        int n = nums.length;

        for (int i = 0; i < n - 2; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue; // skip duplicates

            int left = i + 1;
            int right = n - 1;

            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];

                if (sum == 0) {
                    res.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    left++;
                    right--;

                    // skip duplicates
                    while (left < right && nums[left] == nums[left - 1]) left++;
                    while (left < right && nums[right] == nums[right + 1]) right--;

                } else if (sum < 0) {
                    left++;
                } else {
                    right--;
                }
            }
        }
        return res;
    }
}



=======================================================================================================
4Sum

import java.util.*;

public class FourSum {
    public static List<List<Integer>> fourSum(int[] nums, int target) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        int n = nums.length;

        for (int i = 0; i < n - 3; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            for (int j = i + 1; j < n - 2; j++) {
                if (j > i + 1 && nums[j] == nums[j - 1]) continue;
                int left = j + 1, right = n - 1;
                while (left < right) {
                    long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];
                    if (sum == target) {
                        res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));
                        left++;
                        right--;
                        while (left < right && nums[left] == nums[left - 1]) left++;
                        while (left < right && nums[right] == nums[right + 1]) right--;
                    } else if (sum < target) left++;
                    else right--;
                }
            }
        }
        return res;
    }
}
==================================================================================================√∑√∑√∑√∑√∑√∑√∑√∑√∑√∑=============
Container With Most Water


public class ContainerWithMostWater {

    public static int maxArea(int[] height) {
        int left = 0, right = height.length - 1;
        int max = 0;

        while (left < right) {
            int area = Math.min(height[left], height[right]) * (right - left);
            max = Math.max(max, area);

            // Move the pointer with smaller height
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }

        return max;
    }

    public static void main(String[] args) {
        int[] height = {1,8,6,2,5,4,8,3,7};
        int result = maxArea(height);
        System.out.println("Maximum area: " + result); // Output: 49
    }
}


**********************************************

üåä Problem Explanation (Simple)

You are given an array:

[1,8,6,2,5,4,8,3,7]


Each number is the height of a vertical line.

Your job is to pick two lines that can hold maximum water between them.

Water is stored as a rectangle between two lines.

üß† How do we calculate area (water)?

Formula:

Area = (shorter line) √ó (distance between two lines)

Why shorter line?
Because water spills out from the shorter side.

Example:
If heights are 8 and 3 ‚Üí
Water can go only up to 3 height.

So:

area = min(8, 3) * distance


Distance means:
rightIndex - leftIndex

üéØ Two Pointer Logic (SUPER IMPORTANT)

We start with:

left = first line
right = last line


Why?

Because this gives us the maximum width.

After calculating area, we have two heights:

Example:

height[left] = 1
height[right] = 7


The shorter one is 1.

‚Üí Water can only go up to height 1
So if we move the taller line (7), it won‚Äôt help.

üí° Only moving the smaller height can give a better result.

That is the golden rule:

if leftHeight < rightHeight: left++
else: right--


========================================================================================

Trapping Rain Water (Two Pointer version)


class Main {
    public static void main(String[] args) {
        int[] arr = {2, 1, 5, 6, 7, 7};
        int water = 0, leftmax = 0, rightmax = 0;
        int l = 0, r = arr.length - 1;

        while (l < r) {
            if (arr[l] < arr[r]) {
                if (leftmax < arr[l]) {
                    leftmax = arr[l];
                } else {
                    water += leftmax - arr[l]; // ‚úÖ correct difference
                }
                l++;
            } else {
                if (rightmax <= arr[r]) {
                    rightmax = arr[r];
                } else {
                    water += rightmax - arr[r]; // ‚úÖ correct difference
                }
                r--;
            }
        }

        System.out.println("Total trapped water: " + water);
    }
}




=========================================={{{{{{{==========================================
Remove Duplicates from Sorted Array

Move Zeroes

Sort Colors (Dutch National Flag problem)

Minimum Difference Pair from Two Arrays

Intersection of Two Arrays

3Ô∏è‚É£ Fast & Slow Pointers (Cycle Detection)

Used in linked lists / circular arrays.

Problems:

Linked List Cycle Detection

Find the Starting Node of Cycle in Linked List


==========================================================================================
Happy Number

import java.util.*;

class Main {
    public static void main(String[] args) {
        int n = 19; // try changing this number
        if (isHappy(n))
            System.out.println(n + " is a Happy Number üòä");
        else
            System.out.println(n + " is NOT a Happy Number üò¢");
    }

    public static boolean isHappy(int n) {
        Set<Integer> seen = new HashSet<>();

        while (n != 1 && !seen.contains(n)) {
            seen.add(n);
            n = getSquareSum(n);
        }

        return n == 1;
    }

    private static int getSquareSum(int n) {
        int sum = 0;
        while (n > 0) {
            int digit = n % 10;
            sum += digit * digit;
            n /= 10;
        }
        return sum;
    }
}


=========================================================================================
Middle of Linked List

Palindrome Linked List (using reverse 2nd half)

Detect Cycle in Circular Array

Find Duplicate Number (Floyd‚Äôs cycle detection)

Intersection Node of Two Linked Lists

4Ô∏è‚É£ Merge Intervals Pattern

Used when problems involve overlapping in

tervals.

Problems:
===================================================================================================================================
Merge Intervals

import java.util.*;

public class MergeIntervals {
    public static int[][] merge(int[][] intervals) {
        if (intervals.length <= 1) return intervals;

        Arrays.sort(intervals, (a, b) -> a[0] - b[0]); // sort by start
        List<int[]> result = new ArrayList<>();
        int[] current = intervals[0];

        for (int i = 1; i < intervals.length; i++) {
            if (intervals[i][0] <= current[1]) { // overlap
                current[1] = Math.max(current[1], intervals[i][1]);
            } else {
                result.add(current);
                current = intervals[i];
            }
        }
        result.add(current);

        return result.toArray(new int[result.size()][]);
    }

    public static void main(String[] args) {
        int[][] intervals = {{1,3},{2,6},{8,10},{15,18}};
        int[][] merged = merge(intervals);
        for (int[] interval : merged) System.out.println(Arrays.toString(interval));
    }
}

======================================================================================================


Insert Interval




import java.util.*;

public class InsertInterval {
    public static int[][] insert(int[][] intervals, int[] newInterval) {
        List<int[]> result = new ArrayList<>();
        int i = 0;

        // Add intervals before newInterval
        while (i < intervals.length && intervals[i][1] < newInterval[0]) {
            result.add(intervals[i++]);
        }

        // Merge overlapping intervals
        while (i < intervals.length && intervals[i][0] <= newInterval[1]) {
            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);
            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);
            i++;
        }
        result.add(newInterval);

        // Add remaining intervals
        while (i < intervals.length) result.add(intervals[i++]);

        return result.toArray(new int[result.size()][]);
    }

    public static void main(String[] args) {
        int[][] intervals = {{1,3},{6,9}};
        int[] newInterval = {2,5};
        int[][] merged = insert(intervals, newInterval);
        for (int[] interval : merged) System.out.println(Arrays.toString(interval));
    }
}
=====================================================================================================

Interval List Intersections

import java.util.*;

public class IntervalListIntersections {
    public static void main(String[] args) {
        int[][] A = {{0,2},{5,10},{13,23},{24,25}};
        int[][] B = {{1,5},{8,12},{15,24},{25,26}};
        
        int[][] result = intervalIntersection(A, B);
        
        for (int[] interval : result) {
            System.out.println(Arrays.toString(interval));
        }
    }
    
    public static int[][] intervalIntersection(int[][] A, int[][] B) {
        List<int[]> result = new ArrayList<>();
        int i = 0, j = 0;
        
        while (i < A.length && j < B.length) {
            int start = Math.max(A[i][0], B[j][0]);
            int end = Math.min(A[i][1], B[j][1]);
            
            if (start <= end) {
                result.add(new int[]{start, end});
            }
            
            // Move the interval that ends first
            if (A[i][1] < B[j][1]) i++;
            else j++;
        }
        
        return result.toArray(new int[result.size()][]);
    }
}



============================================================================================================
Minimum Number of Meeting Rooms



import java.util.*;

public class MinimumMeetingRooms {
    public static void main(String[] args) {
        int[][] intervals = {{0,30},{5,10},{15,20}};
        System.out.println(minMeetingRooms(intervals));
    }
    
    public static int minMeetingRooms(int[][] intervals) {
        if (intervals.length == 0) return 0;
        
        int n = intervals.length;
        int[] start = new int[n];
        int[] end = new int[n];
        
        for (int i = 0; i < n; i++) {
            start[i] = intervals[i][0];
            end[i] = intervals[i][1];
        }
        
        Arrays.sort(start);
        Arrays.sort(end);
        
        int rooms = 0, endPtr = 0;
        
        for (int i = 0; i < n; i++) {
            if (start[i] < end[endPtr]) {
                rooms++; // need another room
            } else {
                endPtr++; // meeting ended
            }
        }
        
        return rooms;
    }
}


================================================================================================================

Employee Free Time

Non-overlapping Intervals

Task Scheduler (interval + heap hybrid)

5Ô∏è‚É£ Cyclic Sort Pattern

Used for array problems with numbers in a range (1..n).

Problems:

Cyclic Sort (base)
==========================================================================================
Find Missing Number

üü¢ 1Ô∏è‚É£ Find the Missing Number

üëâ Numbers are from 0 to n (one number missing).

üîπ Logic

Since range is 0..n, each number should be at index num.

One number is missing ‚Üí one index will not have the correct number.

üîπ Code
public class MissingNumber {
    public static int findMissingNumber(int[] nums) {
        int i = 0;
        while (i < nums.length) {
            int correctIndex = nums[i];
            if (nums[i] < nums.length && nums[i] != nums[correctIndex]) {
                int temp = nums[i];
                nums[i] = nums[correctIndex];
                nums[correctIndex] = temp;
            } else {
                i++;
            }
        }

        for (i = 0; i < nums.length; i++) {
            if (nums[i] != i)
                return i;
        }
        return nums.length; // if all 0..n-1 are present
    }

    public static void main(String[] args) {
        int[] nums = {3, 0, 1};
        System.out.println(findMissingNumber(nums)); // Output: 2
    }
}


‚è±Ô∏è Time: O(n)‚ÄÉüíæ Space: O(1)



================================================================================================
Find All Missing Numbers

üü¢ 2Ô∏è‚É£ Find All Missing Numbers

üëâ Numbers are from 1 to n but some are missing and some may repeat.

üîπ Logic

After cyclic sorting:

Numbers that are not at their correct index are missing.
Missing number = index + 1

üîπ Code
import java.util.*;

public class AllMissingNumbers {
    public static List<Integer> findDisappearedNumbers(int[] nums) {
        int i = 0;
        while (i < nums.length) {
            int correctIndex = nums[i] - 1;
            if (nums[i] != nums[correctIndex]) {
                int temp = nums[i];
                nums[i] = nums[correctIndex];
                nums[correctIndex] = temp;
            } else {
                i++;
            }
        }

        List<Integer> missing = new ArrayList<>();
        for (i = 0; i < nums.length; i++) {
            if (nums[i] != i + 1)
                missing.add(i + 1);
        }
        return missing;
    }

    public static void main(String[] args) {
        int[] nums = {4,3,2,7,8,2,3,1};
        System.out.println(findDisappearedNumbers(nums)); // Output: [5,6]
    }
}


‚è±Ô∏è Time: O(n)‚ÄÉüíæ Space: O(1)


===================================================================================================

Find the Duplicate Number

public class FindDuplicate {
    public static int findDuplicate(int[] nums) {
        int i = 0;
        while (i < nums.length) {
            if (nums[i] != i + 1) {
                int correctIndex = nums[i] - 1;
                if (nums[i] == nums[correctIndex]) return nums[i];
                int temp = nums[i];
                nums[i] = nums[correctIndex];
                nums[correctIndex] = temp;
            } else {
                i++;
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        int[] nums = {3,1,3,4,2};
        System.out.println(findDuplicate(nums)); // Output: 3
    }
}


========================================================================================================

Find All Duplicates in an Array

üü¢ 4Ô∏è‚É£ Find All Duplicates in an Array

üëâ Multiple numbers appear twice.

üîπ Logic

After sorting with cyclic sort:

If nums[i] != i + 1, then nums[i] is a duplicate.

üîπ Code
import java.util.*;

public class AllDuplicates {
    public static List<Integer> findDuplicates(int[] nums) {
        int i = 0;
        while (i < nums.length) {
            int correctIndex = nums[i] - 1;
            if (nums[i] != nums[correctIndex]) {
                int temp = nums[i];
                nums[i] = nums[correctIndex];
                nums[correctIndex] = temp;
            } else {
                i++;
            }
        }

        List<Integer> duplicates = new ArrayList<>();
        for (i = 0; i < nums.length; i++) {
            if (nums[i] != i + 1)
                duplicates.add(nums[i]);
        }
        return duplicates;
    }

    public static void main(String[] args) {
        int[] nums = {4,3,2,7,8,2,3,1};
        System.out.println(findDuplicates(nums)); // Output: [2,3]
    }
}


===================================================================================================================

First Missing Positive


üü¢ 5Ô∏è‚É£ First Missing Positive

üëâ Find the smallest missing positive integer (can include negatives and zeros).

üîπ Logic

Ignore negative and out-of-range numbers.

Place each positive number x at index x - 1.

The first index where nums[i] != i + 1 ‚Üí missing positive.

üîπ Code
public class FirstMissingPositive {
    public static int firstMissingPositive(int[] nums) {
        int i = 0;
        while (i < nums.length) {
            int correctIndex = nums[i] - 1;
            if (nums[i] > 0 && nums[i] <= nums.length && nums[i] != nums[correctIndex]) {
                int temp = nums[i];
                nums[i] = nums[correctIndex];
                nums[correctIndex] = temp;
            } else {
                i++;
            }
        }

        for (i = 0; i < nums.length; i++) {
            if (nums[i] != i + 1)
                return i + 1;
        }
        return nums.length + 1;
    }

    public static void main(String[] args) {
        int[] nums = {3,4,-1,1};
        System.out.println(firstMissingPositive(nums)); // Output: 2
    }
}
==================================================================================================================
Set Mismatch




===================================================================================================================
6Ô∏è‚É£ In-place Linked List Reversal

Used for reversing linked lists in parts.

Problems:

Reverse Linked List

Reverse Linked List II (between positions m and n)

Reverse Nodes in K-Group

Rotate Linked List

Reorder List

Swap Nodes in Pairs

7Ô∏è‚É£ Tree BFS Pattern

Level-order traversal type.

Problems:

Binary Tree Level Order Traversal

Binary Tree Zigzag Level Order Traversal

Average of Levels in Binary Tree

Maximum Depth of Binary Tree (BFS)

Minimum Depth of Binary Tree

Binary Tree Right Side View

Cousins in Binary Tree

8Ô∏è‚É£ DFS (Recursion/Stack)

Used for exploring trees/graphs recursively.

Problems:

Maximum Depth of Binary Tree (DFS)

Diameter of Binary Tree

Path Sum I / II

Symmetric Tree (DFS)

Subtree of Another Tree

Count Good Nodes in Binary Tree

Number of Islands (DFS version)

9Ô∏è‚É£ Two Heaps Pattern

Used for median and scheduling problems.

Problems:

Find Median from Data Stream

Sliding Window Median

IPO (maximize capital with projects)

Find Right Interval

Meeting Rooms II (Heap version)

üîü Subsets Pattern

Used for generating combinations / permutations.

Problems:

Subsets (all subsets)

Subsets II (with duplicates)

Permutations

Permutations II (with duplicates)

Combination Sum

Combination Sum II

Palindrome Partitioning

Letter Combinations of a Phone Number

1Ô∏è‚É£1Ô∏è‚É£ Modified Binary Search

Used for rotated arrays, peaks, searching problems.

Problems:

Binary Search (base)

Search in Rotated Sorted Array

Find Minimum in Rotated Sorted Array

Find Peak Element

First and Last Position of Element in Sorted Array

Single Element in a Sorted Array

Median of Two Sorted Arrays

1Ô∏è‚É£2Ô∏è‚É£ Bitwise XOR Pattern

Used for finding missing / unique elements.

Problems:

Single Number (every element appears twice except one)

Single Number II (appears 3 times except one)

Missing Number

Two Single Numbers (find 2 unique numbers in array)

Find XOR of numbers in range

1Ô∏è‚É£3Ô∏è‚É£ Top K Elements (Heap)

Used with PriorityQueue.

Problems:

Kth Largest Element in Array

Top K Frequent Elements

Top K Frequent Words

K Closest Points to Origin

Connect Ropes to Minimize Cost

Reorganize String

Sort Characters by Frequency

1Ô∏è‚É£4Ô∏è‚É£ 0/1 Knapsack DP

Classic subset DP.

Problems:

0/1 Knapsack

Subset Sum Problem

Partition Equal Subset Sum

Target Sum

Coin Change

Minimum Number of Coins to Make Amount

Unbounded Knapsack

1Ô∏è‚É£5Ô∏è‚É£ Topological Sort (Graph Ordering)

Used in DAG problems.

Problems:

Course Schedule I

Course Schedule II

Alien Dictionary

Minimum Height Trees

Sequence Reconstruction

1Ô∏è‚É£6Ô∏è‚É£ Greedy Pattern

Used when locally optimal = globally optimal.

Problems:

Jump Game I

Jump Game II

Gas Station

Candy Distribution

Non-overlapping Intervals (greedy)

Minimum Number of Arrows to Burst Balloons

1Ô∏è‚É£7Ô∏è‚É£ Matrix Traversal Pattern

Used for grid/2D problems.

Problems:

Number of Islands

Word Search

Surrounded Regions

Rotting Oranges

Spiral Matrix

Flood Fill

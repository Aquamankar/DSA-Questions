Day 4: Strings â€“ Reversal, Char Count

Important Problems:

1.1 convert String to Number

String str = "123";
int num = Integer.parseInt(str);
System.out.println(num);  // Output: 123


1.2 Collect numbers from String of "aaa123bbb456"

String input = "aaa123bbb456";
StringBuilder numbers = new StringBuilder();

for (char c : input.toCharArray()) {
    if (Character.isDigit(c)) {
        numbers.append(c);
    }
}

System.out.println(numbers.toString());  // Output: 123456


1.3 Sum of numbers in String "abc123def456gkl"
public class Main {
    public static void main(String[] args) {
        String s = "abc123lmn456xyz789";

        int sum = 0;

        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (Character.isDigit(c)) {
                int digit = c - '0'; // or use Character.getNumericValue(c)
                sum += digit;
            }
        }

        System.out.println("Sum of all digits = " + sum);  // Output: 1+2+3+4+5+6+7+8+9 = 45
    }
}



1.Reverse a string (in-place using two pointers).


2.Reverse each word in a sentence.


3.Check if a string is a palindrome.


// Online Java Compiler
// Use this editor to write, compile and run your Java code online

class Main {
    public static void main(String[] args) {
        System.out.println("Try programiz.pro");
        String s="ate";
    
        boolean flag=isPalindrom(s);
              System.out.println("palindrom " + flag );
      
    }
    
     public static boolean isPalindrom(String  s){
             int left=0, right=s.length()-1;
           while(left<=right){
            if(s.charAt(left) == s.charAt(right)){
                left++;
                right--;
                continue;
            }
            else{
                return false;
            }
        }
        return true;
     }
}

----------------------------------------------------------------------------


4.Count the number of vowels and consonants.

4.Count the number of vowels and consonants.

      String str = "1aaa23abauo";
      String vowels="aeiouAEIOU";
      int vcount=0;
      int ccount=0;
      
      for(char c:str.toCharArray()){
          if(!Character.isDigit(c)){
              if(vowels.indexOf(c) != -1){
                  vcount++;
              
              }
              else{
                  ccount++;
              }
          }
      }
      System.out.println("Try programiz.pro  vowels " +  vcount);
        System.out.println("Try programiz.pro  consonant " +  ccount);

--------------------------------------------------------------------------------------------------------------------

5.Find the most frequent character in a string.


6.Remove all whitespaces from a string.


7.Convert a string to lowercase and uppercase.


8.Find the first non-repeating character.

import java.util.*;

class Main {
    public static void main(String[] args) {
        String str1 = "civic";   // already a palindrome
        String str2 = "ivicc";   // can be rearranged to "civic"
        String str3 = "hello";   // cannot form palindrome

        System.out.println(str1 + " â†’ " + canFormPalindrome(str1));
        System.out.println(str2 + " â†’ " + canFormPalindrome(str2));
        System.out.println(str3 + " â†’ " + canFormPalindrome(str3));
    }

    static boolean canFormPalindrome(String str) {
        Map<Character, Integer> freq = new HashMap<>();

        // Count frequencies
        for (char c : str.toCharArray()) {
            freq.put(c, freq.getOrDefault(c, 0) + 1);
        }

        int oddCount = 0;
        for (int count : freq.values()) {
            if (count % 2 != 0) {
                oddCount++;
            }
            if (oddCount > 1) return false; // More than one odd frequency â†’ not possible
        }

        return true;
    }
}
---------------------------------------------------------_--------------------------------------------------6

9.Remove duplicate characters from a string.


10.Check if two strings are rotations of each other.


import java.util.*;

class Main {
    public static void main(String[] args) {
        String a = "abcd";
        String b = "cdab";

        // 10. Check if two strings are rotations of each other.
        if (a.length() != b.length()) {
            System.out.println("False");
            return;
        }

        String c = a + a;
        if (c.contains(b)) {
            System.out.println("True");  // âœ… b is a rotation of a
        } else {
            System.out.println("False");
        }
    }
}


----------------------------------------------------------------------------------------------------------------------

Day 5: Strings â€“ Palindromes, Anagrams

ðŸ”¹ Important Problems:

11.Check if a string is a palindrome (ignore non-alphanumerics).


12.Find the longest palindromic substring (expand around center).


13.Check if two strings are anagrams.


14.Group anagrams from a list of strings.


15.Check if a string can be rearranged to form a palindrome.


16.Count all palindromic substrings.


17.Remove minimum characters to make a string palindrome.

ans->
public class Main {
    public static void main(String[] args) {
        String s = "abcda";
        int minDeletions = minDeletionsToMakePalindrome(s);
        System.out.println("Minimum deletions to make palindrome: " + minDeletions);
    }

    public static int minDeletionsToMakePalindrome(String s) {
        int lps = longestPalindromicSubsequence(s);
        return s.length() - lps;
    }

    public static int longestPalindromicSubsequence(String s) {
        String rev = new StringBuilder(s).reverse().toString();
        int n = s.length();
        int[][] dp = new int[n + 1][n + 1];

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (s.charAt(i - 1) == rev.charAt(j - 1))
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                else
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return dp[n][n];
    }
}


------------------------------------------------------------------------------------------------------------------
18.Check if two strings are meta strings (can be made equal by swapping two characters).

public class MetaStrings {
    public static boolean areMeta(String s1, String s2) {
        if (s1 == null || s2 == null) return false;
        if (s1.length() != s2.length()) return false;
        if (s1.equals(s2)) return false; // requires exactly one swap to fix, not zero

        int first = -1, second = -1, diffs = 0;

        for (int i = 0; i < s1.length(); i++) {
            if (s1.charAt(i) != s2.charAt(i)) {
                diffs++;
                if (first == -1) first = i;
                else if (second == -1) second = i;
                else return false; // more than 2 differences
            }
        }

        if (diffs != 2) return false;

        return s1.charAt(first) == s2.charAt(second)
            && s1.charAt(second) == s2.charAt(first);
    }

    public static void main(String[] args) {
        System.out.println(areMeta("converse", "conserve")); // true (swap r & v)
        System.out.println(areMeta("geeks", "keegs"));       // true
        System.out.println(areMeta("abcd", "abdc"));         // true
        System.out.println(areMeta("abcd", "abcd"));         // false (already equal)
        System.out.println(areMeta("abc", "abx"));           // false
        System.out.println(areMeta("ab", "ba"));             // true
        System.out.println(areMeta("aab", "aba"));           // true
        System.out.println(areMeta("abca", "abac"));         // true
        System.out.println(areMeta("abc", "cba"));           // false (3 diffs)
    }
}
---_----------------------------------------------------------------------------------------------------------

19.Find all anagrams of a pattern in a text.


20.Longest palindromic subsequence (DP).



Day 6: Strings â€“ Compression, Rotation

21.String compression: Â·  String compression (e.g., "aaabb" â†’ "a3b2").

22.Â·  Â·  Check if one string is a rotation of another (e.g., "ABCD" and "CDAB").



--_--------------_-------------------------_------_----------_---------------------------
23.Â·  Â·  Left rotate a string by k positions.

public static String leftRotate(String str, int k) {
    k = k % str.length(); // To handle k > str.length
    return str.substring(k) + str.substring(0, k);
}


-_-----------------------------------------------------------_--_-_---_----
24.Â·  Â·  Right rotate a string by k positions.

public static String rightRotate(String str, int k) {
    int n = str.length();
    k = k % n;
    return str.substring(n - k) + str.substring(0, n - k);
}



--------------------------------------_-----------------_--_--_-----_-----_---_-
25.Â·  Â·  Implement basic string matching (indexOf).

     brute force->>>>>

public class StringMatcher {

    public static int indexOf(String text, String pattern) {
        int n = text.length();
        int m = pattern.length();

        // Edge cases
        if (m == 0) return 0;
        if (m > n) return -1;

        // Try every starting index in text
        for (int i = 0; i <= n - m; i++) {
            int j = 0;
            // Check if substring text[i..i+m) matches pattern
            while (j < m && text.charAt(i + j) == pattern.charAt(j)) {
                j++;
            }
            if (j == m) {
                return i; // Match found
            }
        }
        return -1; // No match
    }

    public static void main(String[] args) {
        System.out.println(indexOf("hello world", "world"));  // Output: 6
        System.out.println(indexOf("abc", "d"));              // Output: -1
        System.out.println(indexOf("abc", ""));               // Output: 0
    }
}


----------------- -------------    KMP indexOf -----------------------------------


public class KMPMatcher {

    // Main function to find the first index of pattern in text
    public static int indexOf(String text, String pattern) {
        if (pattern.isEmpty()) return 0;

        int[] lps = buildLPS(pattern);  // Preprocess pattern
        int i = 0, j = 0;               // i: text pointer, j: pattern pointer

        while (i < text.length()) {
            if (text.charAt(i) == pattern.charAt(j)) {
                i++;
                j++;
                if (j == pattern.length()) {
                    return i - j;  // match found
                }
            } else {
                if (j != 0) {
                    j = lps[j - 1];  // fall back in pattern
                } else {
                    i++;  // move forward in text
                }
            }
        }

        return -1;  // no match
    }

    // Builds the Longest Prefix Suffix (LPS) array
    private static int[] buildLPS(String pattern) {
        int[] lps = new int[pattern.length()];
        int len = 0;  // length of the previous longest prefix suffix
        int i = 1;

        while (i < pattern.length()) {
            if (pattern.charAt(i) == pattern.charAt(len)) {
                len++;
                lps[i] = len;
                i++;
            } else {
                if (len != 0) {
                    len = lps[len - 1];  // fall back
                } else {
                    lps[i] = 0;
                    i++;
                }
            }
        }
        return lps;
    }

    public static void main(String[] args) {
        System.out.println(indexOf("hello world", "world"));  // Output: 6
        System.out.println(indexOf("abcdabcabcd", "abcd"));   // Output: 0
        System.out.println(indexOf("abcdabcabcd", "abcda"));  // Output: -1
    }
}



----------------------------------------------------------------------------------------------------------------------------------------
        

26.Â·  Â·  Replace spaces with %20 (URLify).


-----------------------------------------------------------------------------------------------------------------------------------------

27.Â·  Â·  Find the smallest window in a string containing all characters of another.


import java.util.*;

class Main {
    public static String minWindow(String s, String t) {
        if (s.length() < t.length()) return "";

        Map<Character, Integer> tFreq = new HashMap<>();
        for (char c : t.toCharArray()) {
            tFreq.put(c, tFreq.getOrDefault(c, 0) + 1);
        }

        int required = tFreq.size();
        int formed = 0;

        Map<Character, Integer> windowFreq = new HashMap<>();
        int left = 0, right = 0;
        int minLen = Integer.MAX_VALUE;
        int minStart = 0;

        while (right < s.length()) {
            char c = s.charAt(right);
            windowFreq.put(c, windowFreq.getOrDefault(c, 0) + 1);

            if (tFreq.containsKey(c) && windowFreq.get(c).intValue() == tFreq.get(c).intValue()) {
                formed++;
            }

            while (formed == required) {
                if (right - left + 1 < minLen) {
                    minLen = right - left + 1;
                    minStart = left;
                }

                char leftChar = s.charAt(left);
                windowFreq.put(leftChar, windowFreq.get(leftChar) - 1);
                if (tFreq.containsKey(leftChar) && windowFreq.get(leftChar) < tFreq.get(leftChar)) {
                    formed--;
                }
                left++;
            }

            right++;
        }

        return minLen == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLen);
    }

    public static void main(String[] args) {
        String s = "ADOBECODEBANC";
        String t = "ABC";
        System.out.println("Smallest Window: " + minWindow(s, t));
    }
}


---------------------------------------------------------------------------------------------------------------------------------------------
28.Â·  Â·  Remove characters from string2 that are present in string1.

ans 
public static String removeChars(String s1, String s2) {
    Set<Character> set = new HashSet<>();
    for (char c : s1.toCharArray()) set.add(c);

    StringBuilder result = new StringBuilder();
    for (char c : s2.toCharArray()) {
        if (!set.contains(c)) result.append(c);
    }

    return result.toString();
}

--_---------------------_------------_--------------------------------------------------------------------------

29.  Check if two strings are isomorphic.

import java.util.*;

class Main {
    public static void main(String[] args) {
        String a = "egg";
        String b = "add";

        if (a.length() != b.length()) {
            System.out.println("Not isomorphic");
            return;
        }

        Map<Character, Character> map1 = new HashMap<>();
        Map<Character, Character> map2 = new HashMap<>();

        boolean isIsomorphic = true;

        for (int i = 0; i < a.length(); i++) {
            char c1 = a.charAt(i);
            char c2 = b.charAt(i);

            if (map1.containsKey(c1)) {
                if (map1.get(c1) != c2) {
                    isIsomorphic = false;
                    break;
                }
            } else {
                map1.put(c1, c2);
            }

            if (map2.containsKey(c2)) {
                if (map2.get(c2) != c1) {
                    isIsomorphic = false;
                    break;
                }
            } else {
                map2.put(c2, c1);
            }
        }

        System.out.println(isIsomorphic ? "Isomorphic" : "Not isomorphic");
    }
}





-----------------------------------------------------------------------------------------------------------------------


30.Â·  Â·  Multiply two large strings (as numbers) without converting to integer.
Â·  class Main {
    public static void main(String[] args) {
        String num1 = "123";
        String num2 = "456";

        String result = multiplyStrings(num1, num2);
        System.out.println(num1 + " * " + num2 + " = " + result);
    }

    static String multiplyStrings(String num1, String num2) {
        if (num1.equals("0") || num2.equals("0")) return "0";

        int n = num1.length();
        int m = num2.length();
        int[] result = new int[n + m];  // max possible length

        // Multiply each digit
        for (int i = n - 1; i >= 0; i--) {
            for (int j = m - 1; j >= 0; j--) {
                int mul = (num1.charAt(i) - '0') * (num2.charAt(j) - '0');
                int sum = mul + result[i + j + 1]; // existing value at that position

                result[i + j + 1] = sum % 10;       // place digit
                result[i + j] += sum / 10;          // carry
            }
        }

        // Convert result array to string
        StringBuilder sb = new StringBuilder();
        int k = 0;
        while (k < result.length && result[k] == 0) k++; // skip leading zeros
        for (; k < result.length; k++) {
            sb.append(result[k]);
        }

        return sb.toString();
    }
}


----------------------------------------------------------------------------------------------------------------------------
Day 7: Review + Mini Test

1.Find the sum of all even numbers in an array.


2.Check if a string is a valid palindrome considering spaces and punctuation.


3.Merge two sorted arrays into a single sorted array.


4.Implement quick sort on an array.


5.Find the missing number in an array of integers.

----------------------------------------------------------------------------------------------------------------------
Day 8: LinkedList â€“ Reversal, Middle Node


1.Reverse a singly linked list.


2.Find the middle node of a linked list.

Code->>>>>>>

class ListNode {
    int val;
    ListNode next;
    ListNode(int val) {
        this.val = val;
    }
}

public class MiddleOfLinkedList {
    public ListNode findMiddle(ListNode head) {
        if (head == null) return null;

        ListNode slow = head;
        ListNode fast = head;

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        return slow; // This is the middle node
    }
}

----------------------------------------------------------------------------------------------------

3.Detect a cycle in a linked list.




---------------------------------------------------------------------------------------------------
4.Find the n-th node from the end of a linked list.

code->>>>>>>>>>>>>


class ListNode {
    int val;
    ListNode next;
    ListNode(int val) {
        this.val = val;
    }
}

public class NthNodeFromEnd {
    public ListNode findNthFromEnd(ListNode head, int n) {
        if (head == null || n <= 0) return null;

        ListNode fast = head;
        ListNode slow = head;

        // Move fast ahead by n steps
        for (int i = 0; i < n; i++) {
            if (fast == null) return null; // n is greater than the length
            fast = fast.next;
        }

        // Move both fast and slow one step at a time
        while (fast != null) {
            fast = fast.next;
            slow = slow.next;
        }

        return slow;
    }
}
----------------------------------------------------------------------------------------


Merge two sorted linked lists into one sorted list.


code---------------------->

// Online Java Compiler
// Use this editor to write, compile and run your Java code online
import java.util.*;
class Main {
    public static void main(String[] args) {
        System.out.println("Try programiz.pro");
    
    ListNode head=new ListNode(1);
    head.next=new ListNode(2);
    head.next.next=new ListNode(4);
    head.next.next.next=new ListNode(7);
      
      
          ListNode head1=new ListNode(1);
    head1.next=new ListNode(3);
    head1.next.next=new ListNode(5);
    head1.next.next.next=new ListNode(6);  
    
    printList(head1);
       printList(head);
       
       //merge two linkef list
       
  ListNode node=    mergeList(head,head1);
  printList(node);
    
        
    }
    
    public static ListNode mergeList(ListNode l1, ListNode l2){
    
          ListNode dummy=new ListNode(0);
          ListNode curr=dummy;
          
          while(l1 !=null && l2 .next !=null){
              if(l1.val < l2.val){
                  curr.next=l1;
                  l1=l1.next;
              }
              else{
                curr.next=l2;
                l2=l2.next;
              }
              
              curr=curr.next;
              
          }
          
          if(l1.next !=null) curr.next=l1;
          if(l2.next !=null) curr.next=l2;
          
          return dummy.next;
        
    }
    
    public static void    printList( ListNode head){
        while(head !=null){
             System.out.print(head.val +"-> ");
             head=head.next;
        }
         System.out.println("null ");
    }
}

class ListNode{
    
    int val;
    
    ListNode next;
  
  ListNode(int val){
      this.val=val;
  }
}

Day 4: Strings â€“ Reversal, Char Count

Important Problems:

1.Reverse a string (in-place using two pointers).


2.Reverse each word in a sentence.


3.Check if a string is a palindrome.


4.Count the number of vowels and consonants.


5.Find the most frequent character in a string.


6.Remove all whitespaces from a string.


7.Convert a string to lowercase and uppercase.


8.Find the first non-repeating character.


9.Remove duplicate characters from a string.


10.Check if two strings are rotations of each other.


Day 5: Strings â€“ Palindromes, Anagrams

ğŸ”¹ Important Problems:

11.Check if a string is a palindrome (ignore non-alphanumerics).


12.Find the longest palindromic substring (expand around center).


13.Check if two strings are anagrams.


14.Group anagrams from a list of strings.


15.Check if a string can be rearranged to form a palindrome.


16.Count all palindromic substrings.


17.Remove minimum characters to make a string palindrome.


18.Check if two strings are meta strings (can be made equal by swapping two characters).


19.Find all anagrams of a pattern in a text.


20.Longest palindromic subsequence (DP).



Day 6: Strings â€“ Compression, Rotation

21.String compression: Â·  String compression (e.g., "aaabb" â†’ "a3b2").

22.Â·  Â·  Check if one string is a rotation of another (e.g., "ABCD" and "CDAB").
23.Â·  Â·  Left rotate a string by k positions.
24.Â·  Â·  Right rotate a string by k positions.
25.Â·  Â·  Implement basic string matching (indexOf).

     brute force->>>>>

public class StringMatcher {

    public static int indexOf(String text, String pattern) {
        int n = text.length();
        int m = pattern.length();

        // Edge cases
        if (m == 0) return 0;
        if (m > n) return -1;

        // Try every starting index in text
        for (int i = 0; i <= n - m; i++) {
            int j = 0;
            // Check if substring text[i..i+m) matches pattern
            while (j < m && text.charAt(i + j) == pattern.charAt(j)) {
                j++;
            }
            if (j == m) {
                return i; // Match found
            }
        }
        return -1; // No match
    }

    public static void main(String[] args) {
        System.out.println(indexOf("hello world", "world"));  // Output: 6
        System.out.println(indexOf("abc", "d"));              // Output: -1
        System.out.println(indexOf("abc", ""));               // Output: 0
    }
}


----------------- -------------    KMP indexOf -----------------------------------


public class KMPMatcher {

    // Main function to find the first index of pattern in text
    public static int indexOf(String text, String pattern) {
        if (pattern.isEmpty()) return 0;

        int[] lps = buildLPS(pattern);  // Preprocess pattern
        int i = 0, j = 0;               // i: text pointer, j: pattern pointer

        while (i < text.length()) {
            if (text.charAt(i) == pattern.charAt(j)) {
                i++;
                j++;
                if (j == pattern.length()) {
                    return i - j;  // match found
                }
            } else {
                if (j != 0) {
                    j = lps[j - 1];  // fall back in pattern
                } else {
                    i++;  // move forward in text
                }
            }
        }

        return -1;  // no match
    }

    // Builds the Longest Prefix Suffix (LPS) array
    private static int[] buildLPS(String pattern) {
        int[] lps = new int[pattern.length()];
        int len = 0;  // length of the previous longest prefix suffix
        int i = 1;

        while (i < pattern.length()) {
            if (pattern.charAt(i) == pattern.charAt(len)) {
                len++;
                lps[i] = len;
                i++;
            } else {
                if (len != 0) {
                    len = lps[len - 1];  // fall back
                } else {
                    lps[i] = 0;
                    i++;
                }
            }
        }
        return lps;
    }

    public static void main(String[] args) {
        System.out.println(indexOf("hello world", "world"));  // Output: 6
        System.out.println(indexOf("abcdabcabcd", "abcd"));   // Output: 0
        System.out.println(indexOf("abcdabcabcd", "abcda"));  // Output: -1
    }
}




        

26.Â·  Â·  Replace spaces with %20 (URLify).
27.Â·  Â·  Find the smallest window in a string containing all characters of another.
28.Â·  Â·  Remove characters from string2 that are present in string1.
29.Â·  Â·  Check if two strings are isomorphic.
30.Â·  Â·  Multiply two large strings (as numbers) without converting to integer.
Â·  
Day 7: Review + Mini Test

Find the sum of all even numbers in an array.


Check if a string is a valid palindrome considering spaces and punctuation.


Merge two sorted arrays into a single sorted array.


Implement quick sort on an array.


Find the missing number in an array of integers.


Day 8: LinkedList â€“ Reversal, Middle Node

Reverse a singly linked list.


Find the middle node of a linked list.


Detect a cycle in a linked list.


Find the n-th node from the end of a linked list.


Merge two sorted linked lists into one sorted list.

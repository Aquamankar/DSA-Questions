Day 8: LinkedList – Reversal, Middle Node

Reverse a singly linked list.


Find the middle node of a linked list.


Detect a cycle in a linked list.


Find the n-th node from the end of a linked list.


Merge two sorted linked lists into one sorted list.


Day 9: LinkedList – Cycle Detection

Q.1 Detect a cycle in a linked list using Floyd’s Tortoise and Hare Algorithm.

class ListNode {
    int val;
    ListNode next;
    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

public class Main {
    public static void main(String[] args) {
        // Step 1: Create nodes
        ListNode head = new ListNode(1);
        ListNode node2 = new ListNode(2);
        ListNode node3 = new ListNode(3);
        ListNode node4 = new ListNode(4);
        ListNode node5 = new ListNode(5);

        // Step 2: Link nodes
        head.next = node2;
        node2.next = node3;
        node3.next = node4;
        node4.next = node5;

        // Step 3: Create cycle (make 5 point to 3)
        node5.next = node3;

        // Step 4: Detect cycle
        boolean result = hasCycle(head);
        System.out.println("Cycle detected? " + result);
    }

    static boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }

        ListNode slow = head, fast = head;

        while (fast != null && fast.next != null) {
            slow = slow.next;         // move 1 step
            fast = fast.next.next;    // move 2 steps

            if (slow == fast) {
                return true;          // cycle found
            }
        }

        return false; // no cycle
    }
}



-----------------------------------------------------------------------------------------------------------------------------------

Q2. Find the start node of the cycle in a linked list

code->>>>>>>>>>>------------------------------------------------------
// Online Java Compiler
// Use this editor to write, compile and run your Java code online
import java.util.*;
class Main {
    public static void main(String[] args) {
        System.out.println("Try programiz.pro");
        // Common part
        ListNode merge = new ListNode(3);
        merge.next = new ListNode(4);
        merge.next.next = new ListNode(5);

        // List A: 1 -> 2 -> 3 -> 4 -> 5
        ListNode headA = new ListNode(1);
        headA.next = new ListNode(2);
        headA.next.next = merge;

        // List B: 9 -> 3 -> 4 -> 5
        ListNode headB = new ListNode(9);
        headB.next = merge;

        ListNode result = getMergeNode(headA, headB);
        if (result != null) {
            System.out.println("Merge Point: " + result.val);
        } else {
            System.out.println("No merge point.");
        }
    

    
        
    }

    public static ListNode getMergeNode(ListNode headA, ListNode headB) {
        ListNode a = headA;
        ListNode b = headB;

        while (a != b) {
            
            a = (a == null) ? headB : a.next;
             System.out.println("a "+ a);
            b = (b == null) ? headA : b.next;
                 System.out.println("b "+ b);
        }

        return a; // Could be null or the merge point
    }
    
    public static void    printList( ListNode head){
        while(head !=null){
             System.out.print(head.val +"-> ");
             head=head.next;
        }
         System.out.println("null ");
    }
}

class ListNode{
    
    int val;
    
    ListNode next;
  
  ListNode(int val){
      this.val=val;
  }
}
>>>>>>>>>>>>>>>>>>>>>>>---------------------------------------------------

Q3.Implement the merge point in two linked lists.


Q4.Find the intersection point of two linked lists.

-----------------------------------------------------------------------------------------------------------------------------
Q5.Delete a node without head refernce.

class Node {
    int val;
    Node next;
    Node(int val) {
        this.val = val;
        this.next = null;
    }
}

class Main {

    static void printList(Node head) {
        while (head != null) {
            System.out.print(head.val + " -> ");
            head = head.next;
        }
        System.out.println("null");
    }

    // Delete a node without head reference
    static void deleteNode(Node node) {
        if (node == null || node.next == null) {
            throw new IllegalArgumentException("Node to delete is null or the last node.");
        }
        node.val = node.next.val;
        node.next = node.next.next;
    }

    public static void main(String[] args) {
        // Create linked list: 1 -> 2 -> 3 -> 4 -> null
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.next = new Node(3);
        head.next.next.next = new Node(4);

        System.out.println("Original list:");
        printList(head);

        // Suppose we want to delete node with value 3, we need reference to that node
        Node nodeToDelete = head.next.next; // this is node with value 3
        deleteNode(nodeToDelete);

        System.out.println("After deleting node 3:");
        printList(head);
    }
}




--------------------------------------------------------------------------------------------------------------------------------------------------------
Q6.Remove the loop in a linked list.
